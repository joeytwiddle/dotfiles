# .gitconfig



# Essential to avoid warnings
[user]
	name = Paul "Joey" Clark
	email = joey@neuralyte.org



# Many of the following come from http://cheat.errtheblog.com/s/git

# Add colors
# Here 'white' is actually darker than the default!
[color]
	ui = auto
[color "branch"]
	current = green bold reverse   # default = green
	local = yellow   # default = white
	remote = red     # default = red
[color "diff"]
	# Commit messages and author will be pure white; I cannot find a place to configure them.
	# The commit id will be:
	commit = yellow bold reverse
	meta = cyan bold
	frag = magenta
	# Believe it or not, 'white' is a little bit darker than ffffff.  Put 'white' here to get a very light grey :-p
	func = white
	plain = white
	old = red bold
	new = green bold
[color "status"]
	branch = green bold reverse
	added = yellow
	changed = green
	untracked = cyan

# Highlight whitespace in diffs
[color]
	ui = true
[color "diff"]
	# Unfortunately this only shows for *added* lines, not for *removed* lines.  At time of writing, git had no way of doing that.  http://stackoverflow.com/questions/5257553/coloring-white-space-in-git-diffs-output
	whitespace = blue reverse



# May not be for everyone!  Actually does some stuff!
# TODO: Look up what the hell this does and document it!
[core]
	#whitespace=fix,-indent-with-non-tab,trailing-space,cr-at-eol
	excludesfile = /home/joey/.gitignore.global
	# Wrap lines when reading diffs
	# This sometimes drops the top of the log off the top of the screen, which is annoying
	#pager = less -r



# Aliases
[alias]
	st = status
	ci = commit
	br = branch
	co = checkout
	df = diff
	dc = diff --cached
	# Adds file summaries to the standard log
	lf = log --stat
	# Adds actual diffs to the standard log
	lg = log -p -m
	# Summaries (without/with branches?)
	#lol = log --graph --decorate --pretty=oneline --abbrev-commit
	lol = log --graph --pretty=format:'%C(yellow)%h%C(magenta bold)%d%C(reset) %s %C(cyan)- %an (%ar)%Creset'
	lola = log --graph --decorate --pretty=oneline --abbrev-commit --all
	prettylog = log --graph --full-history --all --color --pretty=format:"%x1b[31m%h%x09%x1b[32m%d%x1b[0m%x20%s"
	ls = ls-files
	# Show files ignored by git:
	ign = ls-files -o -i --exclude-standard
	ll = log -U0 -p -m
	ld = log -p --word-diff=plain -m
	# -p shows diffs.  -m shows diffs for merges

	# Joey's:
	# Just a list of the files that have changed on the origin (I hope)
	# You need to do a 'fetch' beforehand but not a 'merge'
	#newfiles = ls-files -u
	#newfiles = diff-files --stat
	# This shows change-counts in local files (and perhaps also what is new on the origin)
	# It can be used to show what files will change when you go git merge FETCH_HEAD
	# BUT note that it shows the *opposite* of what the merge will perform!
	# I.e. additions are red, removals are green!  :P
	whatsnewOrigin = diff-index --color --stat origin
	# Hmmm.  If no origin is set yes in .git/config, then we need to do this:
	# This shows only what is new on the origin (log and diffs!)
	# BUT ofc it only works after git fetch!
	#preview  = diff -p HEAD..origin
	#preview  = log -p HEAD..origin
	#preview  = log -p HEAD..origin/master
	#preview  = log -p HEAD..FETCH_HEAD
	preview = diff-index --color --stat FETCH_HEAD
	previewdiff = diff HEAD..FETCH_HEAD
	#whatsnew = log --stat HEAD..FETCH_HEAD
	whatsnew = log --graph --pretty=format:'%C(yellow bold reverse)%h%C(reset)%C(magenta bold)%d%C(black bold) %s %C(cyan)- %an (%ar)%Creset%n' --stat HEAD..FETCH_HEAD

	# Just shows the number of commits by each user
	whodidwhat = shortlog -nsw -e

	recent = diff HEAD~~~

	# List the aliases we have
	alias = !git config --list | grep 'alias\\.' | sed 's/alias\\.\\([^=]*\\)=\\(.*\\)/\\1\\\t = \\2/' | sort

	# whatisnotpushed: Preview what will be sent when you push (or if indeed a push is needed).
	# As an alternative, you can read the "ahead" count shown on the second line of git status, or shown when switching between branches with git checkout.
	# Comparing against the origin does not work when we are on a branch, since origin = origin/master.
	#whatisnotpushed = log origin..HEAD --pretty=oneline
	# So use @{u} = upstream instead
	#whatisnotpushed = log @{u}..HEAD --pretty=oneline
	#whatisnotpushed = log HEAD@{u}..HEAD --pretty=oneline
	# or perhaps just compare against FETCH_HEAD?  That is prone to failure if we switch branch.
	whatisnotpushed = log FETCH_HEAD..HEAD --pretty=oneline
	# I suspect @{u} is better than FETCH_HEAD because it will still apply if we switch branch.  However both suffer from the problem that we might not be pushing *to* the upstream.  Our upstream might be master, whilst we are pushing to the current branch.

	# Shortcut:
	winp   = log FETCH_HEAD..HEAD --pretty=oneline

	# Files that will be pushed:
	topush = diff-index --color --stat FETCH_HEAD

	# Compare two branches; commits on one branch that are not reachable from another:
	#   git log branchA ^branchB
	# More examples here: http://gitref.org/inspect/

	# This simply runs whatever command you give it in the shell.
	# The advantage is that shell aliases are always run in the root.
	# So for example, you can now do "git exec make" from any sub-folder of your project, to run make in the project's root folder.
	exec = "!exec "

	# Just a reminder for myself.  Instead of stashing uncommitted changes, you can bring them with you when you switch branch.
	checkout-carrying-unstashed-changes = checkout -m

	# You can use this to apply a stash pop to a dirty tree (to workaround the error "Cannot apply to a dirty working tree, please stage your changes").
	stash-pop-force = !git stash show -p | git apply && git stash drop



### The following options are rather more serious, because they affect how git modifies files.



# % git config core.autocrlf true
#
# autocrlf setting tells git to convert the newlines to the system's standard
# when checking out files, and to LF newlines when committing in
#
# I have this disabled for now, concerned about Beeb lookup tables and other binaries.
# [core]
	# autocrlf=true



# % git config branch.autosetupmerge true
#
# tells git-branch and git-checkout to setup new branches so that git-pull(1)
# will appropriately merge from that remote branch.  Recommended.  Without this,
# you will have to add --track to your branch command or manually merge remote
# tracking branches with "fetch" and then "merge".
#
# Disabled because I want git to be as difficult for me as for someone without my config.
#
#[branch]
#	autosetupmerge = true

# In a similar vein, this will make it so that pushes will go the same place that pulls come from:
#[push]
#	default=tracking



# To ignore whitespace
#
# % git config apply.whitespace nowarn
#
# I have this disabled because I use coffeescript, and in general I like
# whitespace to be meaningful!
#
#[apply]
#	whitespace = nowarn



## Of interest:
# http://stackoverflow.com/questions/849308/pull-push-from-multiple-remote-locations
# (elliot's answer: automatically push to two repositories)
# The basics of setting up a remote tracking branch:
# http://stackoverflow.com/questions/520650/how-do-you-make-an-existing-git-branch-track-a-remote-branch?rq=1


# Use vimdiff once each file to review diffs, by typing git difftool.
# One disadvantage is the ugliness of breaking out with Ctrl-C if you don't want to diff all the remaining files.
# Without this, you may be presented with other options:
#   Other options are available: merge tool candidates: opendiff kdiff3 tkdiff xxdiff meld kompare gvimdiff diffuse ecmerge p4merge araxis bc3 emerge vimdiff
[diff]
	tool = vimdiff
[difftool]
	prompt = false

