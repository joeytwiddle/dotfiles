# What is useful in this file?
#
# Most of this file is just abbreviations for common git operations.  If you
# use git at the command line, using these shorcuts can save you keystrokes.
#
# Viewing history:
#
#   gll shows a log *overview*, with one commit per line, with graph layout.
#
#   gl shows a *detailed* log, including diffs, stats and commit messages and
#      graph.  Keys n and N jump forwards/backwards through diffs.
#
#   gs is git status, and gd is git diff.
#
#   gb lists branches alphabetically, gbd lists branches by date.  [-r] for remotes.
#
#   gco is git checkout, to quickly switch branch.  (gco - to switch to previous)
#
# Staging and committing:
#
#   ga <filename>s will stage the given files with git add.  Use it for new files.
#
#   gap lets you select (y/n) which chunks of code to stage for the next commit.
#       Use this for changes.  It is healthy to overview as you stage.
#
#   gdc shows the "cached" diff of what is staged (what you are about to commit).
#
#   gc -m '_____' is a quick way to commit the staged changes.
#
#   gca -m '_____' amends the previous commit with any newly staged changes,
#       or you can just use it to change the commit message.
#
#   gcane adds the currently staged changes to the previous commit, but does
#         not prompt for a commit message (gca --no-edit).
#
#   gcf <commit> adds the currently staged changes to an earlier commit.
#       This is very useful to "fix" a commit you made earlier.  It uses rebase
#       with fixup.  You should not amend commits you have already pushed.
#
# Pulling, merging and pushing:
#
#   gpll is git pull
#
#   gf will fetch new commits for all remotes
#
#   gmo does git merge origin/<current_branch> (or use gm <branch> yourself).
#
#   gmom and gmod merge from origin/master and origin/develop respectively.
#
#   gmr gmrom and gmrod do a rebase instead of a merge, to keep history linear.
#
#   gpo does git push origin <current_branch>
#
#   gpsh is git push.  It pushes to the upstream branch.  gpshf adds --force
#
#   gpsh -u <remote> will push this new branch to the specified remote, and set
#        up tracking.
#
# Stashing (and dropping changes):
#
#   gss and gsp are git stash save and git stash pop respectively.
#   gsd shows the diff/patch of your top stash.
#
#   gssp allows you to select (y/n) which changes to stash, leaving the others.
#
#   gssk My preferred way to drop unwanted changes (e.g. console logs after a
#        bug was fixed)
#        Lets you select (y/n) which changes to destroy (kill).
#        It actually does gssp but then drops the stash afterwards.
#        As a result it is recoverable (e.g. using git-list-dropped-stashes).
#        So it is a less dangerous version of git reset --hard (grh).
#
# Useful tools:
#
#   gbd [-M] [-r] [-n <num>] is "git branch by date", a nice way to see which
#       branches were recently updated.  -r lists remote branches.
#
#   gbs [-M] [.] is "git branch status", a nice way to see which branches are
#       up-to-date with the remote (which need a push and which need a pull).
#
#       Use `gbs .` to show the status of the current branch only (faster).
#
#   The -M argument to gbs and gbd is slower, but will display whether or not
#   each branch has been merged into the current branch.  Cool!
#
#   gbd will only align neatly into columns if you have jsh's columnise-clever
#   installed.  Making that work independently is something I should TODO!
#
#   gmt is a shortcut for git mergetool
#
#   gmr as mentioned earlier does git rebase --rebase-merges
#       You should only use this on branches you have not yet shared with others.
#
# Less used shortcuts:
#
#   gdv and glv open diffs and logs in Vim, folded, for interactive browsing.
#
#   gwinp "git what is not pushed" lists commits on local branch not yet pushed
#   gwinm "git what is not merged" lists new commits from remote not yet merged
#
#   git_status_plus sorts untracked files by modification date, and highlights
#   new files created since you last ran it (so you don't forget to add them).
#
# I hope these shortcuts and tools will be of use to you.
#
# Some of the functions (git_branch_status, git_branch_by_date,
# git_status_plus) will only work on Mac OSX and FreeBSD if you have GNU
# versions of sed, xargs and find near the front of your PATH.

# If you think this file has too many comments in it (you are right), try
# hiding them with: :hi Comment guifg=#222222

# CONSIDER: Turn the aliases into shellscripts so they are available from vim's command line?
#       Put them somewhere and load them onto the PATH optionally.  (Not everyone will want them.)  jsh modules...

# See also: https://github.com/jasoncodes/dotfiles/blob/master/shell/aliases/git.sh

# Note that:
#
#   local foo="$(bar)"
#
# is not the same as:
#
#   local foo
#   foo="$(bar)"
#
# because the latter returns an exit code, but the former masks it.

# If you happen to be using oh-my-zsh's git plugin, redefining its aliases will throw warnings, so we undefine them first.
unalias gs 2>/dev/null
unalias gd 2>/dev/null
unalias gitlog 2>/dev/null
unalias gac 2>/dev/null
unalias gitwhatsup 2>/dev/null
unalias gco 2>/dev/null
# By the way, if you want to undefine a function instead of an alias, this works for bash and zsh:
#   unset -f fn_name

#alias gs='git status'
#alias gs='git_status_user_friendly'
alias gs='git_status_plus'

# Just adds a pager, while still providing colour output
git_status_user_friendly() {
	if [ -t 1 ]
	then
		git -c color.status=always status "$@" |
		#more
		# On Mac, more cannot handle color.  Unless it is given -R.  But Linux more does not recognise that argument!  :P
		# I think the disadvantage with less might be when the output is lesser than the screen height, then more will just display those few lines and quit, but less will occupy the entire screen.  Also, does less destroy scrollback, while more preserves it?
		less -R -E -X
		# But can we use the more-like options for less below on Mac?
                # Hmmm that's not quite as neat: on short output, the bottom part of the screen is filled with empty lines.
		# The problem with doing this search with more is that more skips the first "branch" line, even though it is a match.  And it does not even allow paging up to find it!
		#more +'/^# [^ ].*'
		#less -R +'/^# [^ ].*' -E -X --tilde
		#pager -R +'/^# [^ ].*' -E -X --tilde
	else git status "$@"
	fi
}

# An alternative to git status which highlights *new* untracked files differently.
# Untracked files are listed with most recently modified at the top, and files changed since the last run are highlighted.
git_status_plus() {
	if [ -t 1 ]
	then t=1
	else t=
	fi

	# When there are many unknown files, this process can take a very long time.
	# This subshell is needed so that in zsh, the user can break out of the process with Ctrl-C.
	# Without it, even after spamming Ctrl-C, zsh will not return to the prompt until the processing is complete.
	(

	(
		if [ -n "${t}" ]
		then git -c color.status=always status -uno "$@"
		else git status -uno "$@"
		fi

		echo "#"
		echo "# Untracked files:"
		echo '#   (use "git add <file>..." to include in what will be committed)'
		echo "#"

		local git_root_folder=$(git rev-parse --show-toplevel) || exit 1
		# The .git folder is not always at "${git_root_folder}/.git", e.g. inside of submodules.
		local git_folder=$(git rev-parse --git-dir) || exit 1

		# There is no .git folder inside a submodule
		local current_stats_file="${git_folder}/git_status_plus.current.$USER"
		local previous_stats_file="${git_folder}/git_status_plus.previous.$USER"

		# BUG: If a path is passed as an argument, then this will filter the status list.
		#      But a filtered status list will not compare well with an older unfiltered one!
		# TODO: We should either store different lists for different args,
		#       or we should not allow filtering.

		# Passing a path doesn_t stop --porcelain from reporting files in higher folders.
		# But ideally I only want to see changes below the current folder.
		# So we need to filter the results to the current folder.
		local target_folder
		if [ -z "$1" ]
		then target_folder=$(git rev-parse --show-toplevel)   # project root
		else target_folder="$1"   # specified folder
		fi
		local target_folder_from_root="$(cd "$target_folder" ; git rev-parse --show-prefix)"
		#echo "[log] target_folder_from_root: $target_folder_from_root"

		# -uall lists files below un-added folders; without it only the parent folder is listed
		#git status --porcelain -uall |
		git status --porcelain |
		grep '^?? ' |
		cut -c 4- |
		# Because the process below is slow, we put a limit on how many files we will tolerate.
		# Unfortunately we need to do this now, and not after the sort-by-date.
		# The best solution for the user is to use git ignore properly.
		# The slowness of this process should encourage that!
		# CONSIDER: The following while loop could be replaced by a call to xargs.
		head -n 20000 |
		(
			cd "$git_root_folder"

			#while read file
			#do
			#	# Size and date of file
			#		#stats=$( stat -c '%s %Y' "$file" ) 
			#		#echo "$stats $file"
			#		find "$file" -maxdepth 0 -printf "%s %T@ %p\n" | sed 's+\.[0-9]*++'
			#		#echo "$stats $file" >&2
			#done

			# Do the above find using xargs.
			# The `bash -c '... "$@"' "$0"` trick allows us to place 200 arguments in the middle of the line, as opposed to the end which xargs usually does.
			# This may be very ugly, but it runs a lot faster than invoking find multiple times!
			xargs -d '\n' -n 200 -- bash -c 'find "$@" -maxdepth 0 -printf "%s %T@ %p\n"' "$0" |
			# Remove the fractional part of the date.
			sed 's+\.[0-9]*++'
		) |
		sort -n -k 2 -r > "$current_stats_file"

		#diff "$previous_stats_file" "$current_stats_file" |
		#grep '^>'

		local cursereset="$(cursenorm)"
		local cursenormal="$(cursecyan)"
		local cursehighlight="$(curseyellow;cursebold)"

		local path_prefix="$(git rev-parse --show-prefix)"

		# CONSIDER TODO: The below is very inefficient.  Instead of all these greps, can we sort them and do a one-way diff?
		cat "$current_stats_file" |
		grep "^[0-9]* [0-9]* ${target_folder_from_root}" |
		head -n 1000 |
		while read size date file
		do
			local curseon="$cursenormal"
			# If we haven't seen this file before, or it has changed size/date since last time, then we highlight it
			if ! grep -F -x "$size $date $file" "$previous_stats_file" >/dev/null 2>&1
			then curseon="$cursehighlight"
			fi
			# Find the file path relative to current path
			# This only works for files underneath the current path
			#local relfile="$(printf "%s\n" "$file" | sed "s+^$path_prefix++")"
			local relfile="${file#$path_prefix}"
			# If relfile is "" then presumably it was the current folder "."
			echo "#       ${curseon}${relfile:-.}${cursereset}"
		done

		'cp' -f "$current_stats_file" "$previous_stats_file" 2>/dev/null

		# For debugging:
		'cp' -f "$previous_stats_file" "$previous_stats_file".REAL 2>/dev/null

		echo "#"
	) |
	if [ -t 1 ]
	then less -R -E -X
	else cat
	fi

	)
}

#alias gd='git diff'
gd() {
	# Show color if not piping.  Skip to next file on 'n'.
	if [ -t 1 ]
	then git -c color.diff=always diff "$@" | less -R +'/^diff.*' -X
	else git diff "$@"
	fi
}
# Git Diff Words (also uses -w to ignore whitespace aka indentation)
alias gdw='git diff -w --word-diff=color'
# Git Diff Files
alias gdf='git diff --stat="$COLUMNS"'

# Git Diff Staged / Cached (see which one I use most ... I used gdc!)
#alias gds='gdc'
alias gdc='gd --cached'
alias gdcw='gd --cached --word-diff=color'
alias gdu='gd @{upstream}'

alias ga='git add -v'
# I often like to do git commit -a, and wonder why there is no equivalent git add -a.  In fact there is, but the flag is -u!
alias gau='ga -u'
alias gaa='gau'

#alias gc='git commit'
alias gc='git commit -v'
alias gcnv='gc --no-verify'
alias gca='gc --amend'
alias gcanv='gca --no-verify'
alias gcane='gca --no-edit'
alias gcanenv='gcane --no-verify'

# gc -m but without needing quotes
gcm() {
	gc -m "$*"
}
gcam() {
	gca -m "$*"
}
# gcam could mean -m with --amend or with -a
# With --amend is more of a timesaver, and more consistent with gca.  But it is more dangerous if used accidentally!
#alias gcam='gc --amend -m'
alias gcAm='gc -a -m'
# In reality, I rarely use gcam, so I just disabled it.
alias gci='git commit --interactive'
# -p "patch" allows us to choose which hunks to add or commit
alias gap='ga -p'
# This is better used for git cherry-pick, as that is a greater saving, and I use it more often.
#alias gcp='gc -p'

# Perform git commit --fixup and do the rebase immediately
#
# For example, to patch the third previous commit with a small bugfix:
#
#     git add -p file_with_minor_fix.c
#
#     gcf HEAD~~
#
git_commit_immediate_fixup() {
	local commit_to_amend="$1"
	if [ -z "$commit_to_amend" ]
	then
		echo "You must provide a target commit!"
		return
	fi

	# We need a static commit ref, in case the commit is something relative like HEAD~
	commit_to_amend="$(git rev-parse "${commit_to_amend}")" || return

	echo ">> Committing"
	git commit --no-verify --fixup "${commit_to_amend}" || return

	echo ">> Performing rebase"
	# If --rebase-merges is not working, you may need to use the older --preserve-merges
	# --autosquash only arranges fixups when using -i, so we use -i with a dummy EDITOR
	EDITOR=true git rebase -i --autosquash --autostash --rebase-merges --no-fork-point "${commit_to_amend}~"
}
alias gcf='git_commit_immediate_fixup'

# The version above is the nice simple one for you to use.
# This version is what Joey is using to debug issues.
git_commit_immediate_fixup_DEBUG_VERSION() {
	local commit_to_amend="$1"
	if [ -z "$commit_to_amend" ]
	then
		echo "You must provide a target commit!"
		return
	fi

	# Occasionally rebase appears to lose commits.
	# In order to learn more about it, and hopefully eventually avoid it, I need to detect when it has happened.
	# We may be able to avoid it by using --no-fork-point (https://stackoverflow.com/a/1628584/99777)
	local do_extra_check=1

	# We need a static commit ref, in case the commit is something relative like HEAD~
	commit_to_amend="$(git rev-parse "${commit_to_amend}")" || return

	echo ">> Committing"
	git commit --no-verify --fixup "${commit_to_amend}" || return
	[ -n "$do_extra_check" ] && git branch --force BACKUP-BEFORE-FIXUP-REBASE HEAD

	echo ">> Performing rebase"
	# If --rebase-merges is not working, you may need to use the older --preserve-merges
	# --autosquash only arranges fixups when using -i, so we use -i with a dummy EDITOR
	EDITOR=true git rebase -i --autosquash --autostash --rebase-merges --no-fork-point "${commit_to_amend}~"

	if [ -n "$do_extra_check" ] && ( [ -d "$git_dir/rebase-merge" ] || [ -d "$git_dir/rebase-apply" ] )
	then
		echo "We cannot check the rebase was identical because it has been paused part way" >&2
		echo "But you can check yourself by running this when finished:" >&2
		echo "    git diff BACKUP-BEFORE-FIXUP-REBASE HEAD"
	elif [ -n "$do_extra_check" ]
	then
		changes="$(git diff HEAD BACKUP-BEFORE-FIXUP-REBASE | wc -l)"
		if [ "$changes" = 0 ]
		then git branch -D BACKUP-BEFORE-FIXUP-REBASE
		else
			echo
			echo "WARNING: The rebased repo does not match the pre-fixup repo.  Here is the diff:"
			echo
			git diff BACKUP-BEFORE-FIXUP-REBASE HEAD
			echo
			echo "You may restore by (stashing anything uncommitted and then) doing: git reset --hard BACKUP-BEFORE-FIXUP-REBASE"
			echo
			return 9
		fi
	fi
}
unalias gcf
alias gcf='git_commit_immediate_fixup_DEBUG_VERSION'

# Performs gap but offers the files in most-recently-modified order.
# This is useful if you have made a few changes tangential to your current task, and now want to "pop" them off into a commit.
# You can easily pick out your most recent changes, and leave your older changes in the working tree.
git_add_patch_by_date() {
	local git_root_folder="$(git rev-parse --show-toplevel)"
	cd "${git_root_folder}"
	local modified_files
	# dash cannot handle the array syntax here.  Even if we hide it in an if, dash still cannot parse this file!
	# (This used to stop my Fluxbox from starting, until I changed my fluxbox startup script from startj to startj-simple.)
	IFS=$'\n' modified_files=($(git status --porcelain | grep '^.M' | sed 's+^.. ++' | sortfilesbydate | reverse))
	# This is a "safer" version, in that dash can parse it.
	# But it is "unsafe" because it cannot handle filenames containing spaces.
	#IFS=$'\n' modified_files="$(git status --porcelain | grep '^.M' | sed 's+^.. ++' | sortfilesbydate | reverse)"
	# This did not allow any user input, and would have suffered the same as below anyway.
	#| xargs -d '\n' git add -p
	# This just puts them back into alphabetical/disk/git order!
	#git add -p "${modified_files[@]}"
	# This offers them in the desired reverse-date order, but now 'q' doesn't work.  Use Ctrl-C instead.
	for file in "${modified_files[@]}"
	do git add -p "${file}"
	done
}
alias gapd='git_add_patch_by_date'

if [ -n "$ZSH_NAME" ]
then
	: #compdef ga=git
fi

git_fetch_all() {
	if [[ "$(git --version | awk '/git/ {print $3}')" < "1.7" ]]
	then
		# This is for older versions of git (<1.7.0) which didn't accept the --all parameter.
		# We could actually perform the same action with the old built-in `git remote update`, but that won't let us fetch tags and do pruning.
		local remote
		git remote |
		while read remote
		do
			echo "Fetching ${remote}"
			git fetch "${remote}" "$@"
		done
	else
		# We use --all if git supports it, although it isn't significantly faster.
		git fetch --all "$@"
	fi
}
# Faster, because it only hits one remote
alias gf='git fetch'
alias gfo='git fetch origin'
# Slower, but fetches from all the remotes
#alias gfa='git_fetch_all'
alias gfa='git_fetch_all --tags --prune'

alias gpl='git pull'
alias gpll='git pull'

#alias gps='git push'
alias gpsh='git push -v'
# Git Push Origin
alias gpo='verbosely git push origin "$(git_get_current_branch)"'
# Git Push Upstream.  Disabled because:
# - 'gpu' is ambiguous: Does it mean `git pull` or `git push` or `git push -u`?
# - Anyway pushing to guessed or real upstream is what Git Push does normally.
# - Conceptually, I believe we should pull from upstream, and push to downstream.
#alias gpu='verbosely git push "$(git_guess_upstream_branch)"'
# -u sets upstream tracking branch
#alias gpu='verbosely git push -u'
# --force will override remote branch even if it is ahead of local branch
# --no-verify will skip running hooks
alias gpshf='git push --force'
alias gpshnv='git push --no-verify'
alias gpshnvf='git push --no-verify --force'

# This is just a reminder how to fix an occasional problem when trying to push (from a non-current local branch?) to a non-existent remote branch
#
# The problem shows up as:
#
#     error: unable to push to unqualified destination: master
#     The destination refspec neither matches an existing ref on the remote nor
#     begins with refs/, and we are unable to guess a prefix based on the source ref.
#
alias gpshharder='echo "Try: git push -u <remote> <local_branch>:refs/heads/<remote_branch>"'

# I wanted to perform `git pull` and `git merge` with `git_autostashed` however they sometimes drop out unfinished, in which case the stash does not get popped as intended.
alias gm='git merge'
alias gmne='git merge --no-edit'
# Git Merge Origin (this branch)
#alias gmo='verbosely git merge "$(git_guess_upstream_branch)"'
alias gmo='verbosely git merge "origin/$(git_get_current_branch)"'
alias gmm='verbosely git merge master'
alias gmmn='verbosely git merge main'
#alias gmu='verbosely git merge "upstream/$(git_get_current_branch)"'
alias gmu='verbosely git merge "$(git_guess_upstream_branch)"'
alias gmom='verbosely git merge origin/master'
alias gmomn='verbosely git merge origin/main'
alias gmod='verbosely git merge origin/develop'
alias gmum='verbosely git merge upstream/master'
alias gmumn='verbosely git merge upstream/main'
alias gmud='verbosely git merge upstream/develop'

alias gmt='git mergetool'
alias gma='git merge --abort'

# Git pull --rebase will attempt to splice the new upstreams commits in before your unpushed commits.
gpr_safe() {
	local current_commit="$(git rev-parse HEAD)"
	echo "Current commit before rebase (in case abort desired): ${current_commit}"
	git pull --rebase=preserve
}
#alias gpr='git pull --rebase=preserve'
alias gpr='gpr_safe'
alias gpp='gpr && git push'
# If you have already fetched the remote branch, or you want to rebase against a branch that isn't upstream, you can use this
grp_safe() {
	local other_branch="$1"
	[ -n "${other_branch}" ] && shift
	[ -z "${other_branch}" ] && other_branch="$(git_guess_upstream_branch)"

	# Optional safety check: If we will be cherry-picking a commit that is already in other branches, rebasing could cause confusion for those branches.
	# But that's not really a problem if those other branches are essentially throwaway branches, or if they are the upstream which we intend to override.
	local base_commit="$(git_find_base_commit "${other_branch}" HEAD)"
	local first_commit_after_base="$(git rev-list "${base_commit}..HEAD" | tail -n 1)"
	if [ -z "${first_commit_after_base}" ]
	then
		# This could happen if you have no local commits that need to be rebased, e.g. if the other_branch already contains this commit.
		echo
		echo "I could not find any local commits after the base commit: ${base_commit}"
		echo
	else
		local branches_containing_rebased_commit="$(git branch -vv -a --contains "${first_commit_after_base}")"
		# We always expect one commit: the current one.  But if there is more than one...
		local count_branches_containing_rebased_commit="$(printf "%s\n" "${branches_containing_rebased_commit}" | wc -l)"
		if [ "${count_branches_containing_rebased_commit}" -gt 1 ]
		then
			echo
			echo "WARNING!  The following branches contain one of the commits that will be rebased:"
			printf "%s\n" "${branches_containing_rebased_commit}"
			echo
			# CONSIDER: Could ask for confirmation to continue (Y/N)?
		fi
	fi

	# Helpful: log the way back
	local current_commit="$(git rev-parse HEAD)"
	echo "Current commit before rebase (in case abort desired): ${current_commit}"
	echo

	git rebase --rebase-merges --autostash "${other_branch}" "$@"
}
#alias grp='git rebase --rebase-merges "$(git_guess_upstream_branch)"'
alias grp='grp_safe'
# Git Merge Rebase (mnemonic)
alias gmr='grp_safe'
alias grpu='grp $(git_guess_upstream_branch)'
alias gmru='gmr $(git_guess_upstream_branch)'
alias gmrom='gmr origin/master'
alias gmromn='gmr origin/main'
alias gmrod='gmr origin/develop'
alias gmrum='gmr upstream/master'
alias gmrumn='gmr upstream/main'
alias gmrud='gmr upstream/develop'

alias gr='git reset'
alias grh='gr --hard'
alias grhu='grh "@{u}"'
alias grhom='grh origin/master'
alias grhomn='grh origin/main'
alias grhod='grh origin/develop'
alias grhum='grh upstream/master'
alias grhumn='grh upstream/main'
alias grhud='grh upstream/develop'

grho() {
	local current_branch="$(git_get_current_branch)"
	verbosely git reset --hard "origin/$current_branch"
}

alias gcp='git cherry-pick'
alias gcpc='git cherry-pick --continue'
alias gcpa='git cherry-pick --abort'

#alias gri='git rebase -i'
alias gri='git rebase --interactive --autosquash --autostash --no-verify'
# I used to include --rebase-merges here, but it started dropping commits during a rebase, so I think it's safer off!
alias griu='gri @{u}'
alias griom='gri origin/master'
alias griomn='gri origin/main'
alias griod='gri origin/develop'
alias grium='gri upstream/master'
alias griumn='gri upstream/main'
alias griud='gri upstream/develop'
alias grc='git rebase --continue'
alias gra='git rebase --abort'

alias grl='git reflog'
alias grll='glc -g'
# This steps through diffs (but over commit messages, which is a little confusing):
#alias grlll='glc -g -p'
# This steps through commits, but over diffs:
#alias grlll='gitlog2 -search "^[a-z0-9]{7}" -g -p'
# This steps through commits and diffs:
alias grlll='gitlog2 -search "^(diff|[a-z0-9]{7}) .*" -g -p'

# Be careful.  'grv' will call 'git remote -v' but 'gr' will call 'git reset'!
alias grv='git remote -v'

alias gt='git tag'

alias fgc=friendlygitcommit
alias lg=gitls
alias gls=gitls
alias glsl=gitls

#alias gp='git preview'   # This was defined in my .gitconfig as: git diff --stat HEAD..FETCH_HEAD
#alias gw='git whatsnew'

#alias gl='git log'
#alias gl='git log -U2 -p -m'
# I thought it might be nice to setup less so that we can jump to the next commit with 'n'
# Unfortunately whilst this provides the feature, git disables colors:
#   gl | less +"/^commit.*" -r
# Oh, fixed it.  Since this make paging commits very fast, now adding --stat
#alias gl='git -c color.ui=always log -U2 -p -m --stat="$COLUMNS" | less -R "+/^commit.*"'
gitlog() {
	# Show color if not piping.  Skip to next file or commit on 'n'.
	if [ -t 1 ]
	then
		git -c color.ui=always log "$@" |
		#less -R +'/^(commit|diff).*' -X
		# Needed when using --graph and -p
		#less -R +'/((^|\*[ |]*)commit .*|(^|\|{0,1} +)diff --(git|combined) .*)'
		# Don't highlight the entire line for diffs; makes commits stand out stronger
		less -R +'/((^|\*[ |]*)commit .*|diff --(git|combined))'
	else git log "$@"
	fi
	# BUG TODO: The --git may show as --combined when using gl -c, so change it for just -- after the pending merge.
}
# The regexp search allows us to quickly skip to the next diff or commit header by pressing `n`.  If you do not wish to jump through the diffs, you have two options:
#   1. Edit the search so it won't hit diff lines.  For example: `/<Left><Left><Left>z<Enter>`.  This will work for the rest of the session.
#   2. Count the number of files in this commit (as shown by --stat), add one, and jump that many times with e.g. `15n`.  This will work just once, so you can use `n` to skip diffs later.

# "Git Log Pure" - the basis for "Git Log Grey" but without colours
# I am not sure how useful -m is.  It shows us the diff of the merge *and* the individual commits from the merged branch, so we see some things twice.  We may want to remove it, or add --no-merges and/or --first-parent, so we can see the individual commits from merged branches, without the merge commits themselves (which would be duplicate information!).  The disadvantage is that by hiding merges, we don't see the correct moment at which the commit entered our local branch.  Perhaps we want to view the merges but not the commits from merged branches!  That is exactly the behaviour of --first-parent; then we should keep -m.  But then we can't see the log messages for those commits.
# So some sensible choices are: -m --first-parent to see the changes at merge time, or neither to see the log messages of individual commits.
# Probably the second is more desirable for gll, the first more desirable for glf or gld (gl).  Especially the first is useful because it shows us the fixed conflict files during a merge.  (So we can check that a merge has not snuck in unwanted code during the conflict resolution.)
# We could also try out --cc or -c options.
# Nah they didn't see helpful.  It's either -m --first-parent or neither.
# I think I originally added -m because I *thought* git log was not showing commit diffs from merged branches.  In fact it does, but it shows them individually, and leaves the merge commit itself empty.
# I am now finding this a little more informative than glg: git log -p --graph --decorate
# I rarely want to use glp directly; I prefer glg because it customizes the color of the commit message.
# OK so I recently had to track down some code which had been deleted/lost during a merge.  I was using git log <filename>.  The *only* way which worked was -c; -cc or neither would not display this line!  So -c all the way... at least for that case!  If -c causes duplicate information to be displayed, perhaps we should use it at the same time as not showing branches.
# The --stat option sometimes abbreviates the filenames it displays.  If you need the whole path, use --numstat instead.
alias glp='gitlog -p -U2 --stat="$COLUMNS"'
# Here --stat show a quick summary of changed files, before actually showing the diffs.  I rather enjoy this when using 'gl' as it lets me decide from the top of each commit whether there are any files I am interested in, and if not I can happily skip straight to the next commit.  In other situations, e.g. when I am planning to read all the details, --stat is just chaff.
# "Git Log Grey" - Like 'gl' except we present my favourite colors
# This is quite close to: git log --decorate -U2 -p -m --stat
# Curiously the alias shows fewer +++s and ---s on the stat output.
# One "advantage" of our custom format over --decorate is that --decorate shows different colors for different decorations.  Whilst this is nice and informative, it looks a little ugly when it combines with the reverse highlighting from our less search.
alias glg='glp --format=format:"%C(yellow bold)commit %H%C(magenta bold)%d%C(reset)%nAuthor: %an <%ae>%nDate:   %ad%n%n    %C(black bold)%s %C(reset)%C(yellow)%Creset%n"'
# Custom_format_bugs: Note that %b is missing (it should come after %s%n, it may show 'Conflicts' list or other useful notes).  But adding it conditionally is a hassle.
# "Git Log" aliases to "Git Log Grey"
#alias gl='glg'
# Now trying this out; use glm for old-ish style (merges merged) or use glg to see individual commits without the graph.
# We should probably swap glg and gl, since gl has a graph and glg does not!
# Interestingly this can show some commits in a different order from glg alone, in the presence of merges.
alias gl='glg --graph'
# Git Log with Diffs
alias gld='gl'
# glx is like gl but without my custom format colours and without my Custom_format_bugs.
alias glx='glp --graph'
# Warning: glg and glc duplicate my color settings.  (Which are also set in my ~/.gitconfig.)  Part of the reason I passed everything through glg/glc was to display decorations (commit labels like HEAD and origin/master).  I have since learned this can be achieved by passing --decorate, so we may be able to reduce some duplication that way.
# "Git Log with Merges-combined/merged)" - shows diffs in the merge, does not show individual commits from merged branches
alias glm='glg -m --first-parent'
# It seems to me that -c should be combined with --first-parent, to avoid seeing the same diffs twice (the final actual merge, as well as the commits on the branch)
# When -c is used, -m does nothing (at least in the example I tested)
# I did tests comparing `glg -c` against `glg -m`, and `glg -c --first-parent` against `glg -m --first-parent`.  Whilst -c did show the full diff of manual merges, it also excluded a lot of stuff!  Notably, merges with no conflicts.  (From the manual: "it lists only files which were modified from all parents").  So I don't see any way to see the true patched of manual merges (-c) without also excluding stuff.  Therefore, use -c only when you think you need it!  :P

# "Git Log Clear" - Single lines, no graph.  Shows more info than: git log --pretty=oneline
# If you want to use this with --stat and --graph then it should have a %n at the end.  But this will make --graph show blank lines even when run without --stat.  Since glf does not use --graph, we don't really need this.
#alias glc='git log --pretty=format:"%C(yellow bold)%h%C(magenta bold)%d%C(reset) %C(black bold)%s %C(reset)%C(cyan)- %an (%ar)%Creset"'
alias glc='git log --pretty=format:"%C(yellow bold)%h%C(magenta bold)%d%C(reset) %C(black bold)%s %C(reset)%C(cyan)- %an (%ad)%Creset" --date=relative'
#alias glct='glc --date=local'
alias glct='git log --pretty=format:"%C(yellow bold)%h%C(reset) %C(cyan)%ad%C(reset)%C(magenta bold)%d%C(reset) %C(black bold)%s %C(reset)%C(cyan)- %an%Creset" --date=local'
alias glctt='git log --pretty=format:"%C(yellow bold)%h%C(reset) %C(cyan)%ad / %cd%C(reset)%C(magenta bold)%d%C(reset) %C(black bold)%s %C(reset)%C(cyan)- %an%Creset" --date=local'

# "Git Log Long" - One per line, with graph
#alias gll='git log --graph --decorate --pretty=oneline --abbrev-commit --all'   # Does not show committer's name or age of commit
#alias gll='git lol'
# Using the same colors as "Git Log Clear" except commits are not bold:
#alias gll='git log --graph --pretty=format:"%C(yellow)%h%C(magenta bold)%d%C(reset) %C(black bold)%s %C(reset)%C(cyan)- %an (%ar)%Creset"'
# Problem: When used with --graph, glc should end in %n.  But we don't want the %n when --graph is not used (e.g. in glf below)!  I don't personally want the %n, but --graph always draws a |\n straight after the formatted text, so it looks messy without it.
alias gll='glc --graph'
alias gllt='glct --graph'
alias glltt='glctt --graph'
# "Git Log Long Minus merges"
# This lists the merge commits themselves, but does not list any of the commits that were brought in by the merge.  This is useful if you have merged things into the current branch, but you are only interested in the commits that were actually made on the current branch.
# When using this, it can be nice to clearly distinguish merges from raw commits.  If your merge commit messages are pure, you can search /Merge.* or cleaner /Merge.* into [^ ]*
# gllm | highlight -bold -reverse "Merge.* into [^ ]*" magenta | more
if which highlight >/dev/null
then
	# Better because it allows arguments to be passed.  Breaks if glc is not aliased until later.
	gllm() {
		gll -m --first-parent "$@" |highlight -bold "Merge.*" blue | less -REX
	}
	#alias gllm='gll -m --first-parent | highlight -bold "Merge.*" blue | less -REX'
else alias gllm='gll -m --first-parent'
fi
# This shows the commits from merged branches (/), but not the merge commits themselves (\).  It takes less space than gll.
alias gllnm='gll --no-merges'
# Git Log Long No Graph
alias gllng='glc'
alias glls='gll --stat="$COLUMNS"'

# "Git Log Word-diffed" - It is debatable whether we want to page through diffs or just whole commits; it kinda depends what the user is looking for that particular time!
alias glw='gl --word-diff=color'
# "Git Log Stats/Summary" - Just file stats, no diffs.  BUG: Not grey, because glg uses glp which does -p (diffs)!
# Deprecated in favour of gls=gitls.  Use glf for this instead.
#alias gls='gitlog --stat="$COLUMNS"'
# "Git Log Files" - Compressed version of "Git Log Stats"
#alias glf='glc --stat="$COLUMNS"'
# New version allows easy n/N searching.  Could be merged with gitlog.
gitlog2() {
	local search
	if [ "$1" = "-search" ]
	then search="$2"; shift; shift
	else search='^$'
	fi
	# Because we pipe to less, we need --color=always to color the stats in glf
	glc --color=always "$@" | less -R +"/$search"
	#glc "$@"
}
alias glf='gitlog2 -search "^[^ ]+" --stat="$COLUMNS"'
# With glf, we can walk commmits with /^[^ ]+
# Just commit info, one per line
# Git Log Files Porcelain: does not abbreviate filenames, shows numbers instead of '+'s and '-'s
alias glfp='gitlog2 -search "^[a-z0-9]{7}" --numstat'

# Some common branches I like to read/search
alias glu='gl @{u}'
alias glom='gl origin/master'
alias glomn='gl origin/main'
alias glod='gl origin/develop'
alias glum='gl upstream/master'
alias glumn='gl upstream/main'
alias glud='gl upstream/develop'
alias gllu='gll @{u}'
alias gllom='gll origin/master'
alias gllomn='gll origin/main'
alias gllod='gll origin/develop'
alias gllum='gll upstream/master'
alias gllumn='gll upstream/main'
alias gllud='gll upstream/develop'

alias gb='git branch'
# Shows latest commit on each branch (although I prefer my gbd for this)
alias gbv='git branch -v'
# Also shows upstream tracking branch (if any)
alias gbvv='git branch -vv'
# Git Branch Force can be used to change the HEAD of a branch that is not the current branch
alias gbf='git branch -f'
# Git Branch Move (Rename)
alias gbm='git branch -m'

# Git View Branches (tree-like)
alias gvb='git log --oneline --decorate --graph --simplify-by-decoration'
# For remotes too, add: --all
# Could also be Git View Tree or Git Tree View, although I might want to save those for gitv!  :P

#alias gbs='git_in_root_dir git bisect start'
alias gbg='git_in_root_dir git bisect good'
alias gbb='git_in_root_dir git bisect bad'
#alias gbr='git_in_root_dir git bisect reset'

alias gco='git checkout'
alias gcob='gco -b'
# Sometimes we can't checkout because there are uncommitted changes to files which differ between the two branches
# This can be handled by `git checkout -m` or by our own `gcos`
alias gcom='gco -m'
alias gcos='git_do_with_changes_stashed gco'
# `git checkout -p [. | path]` allows us to select hunks to reset.  It is a fine-graned version of `git checkout -- <path>`
alias gcop='git checkout -p'

# After successfully doing a 'git checkout', also run the commands in the POST_GIT_CHECKOUT env var.
# Now disabled in favour of the alias above, because that can provide tab-completion from the shell, which this function suppresses
# The proper way to do this is to use git hooks, e.g.: https://github.com/yannvanhalewyn/dotfiles/tree/master/git_template/hooks
# We can't make a global git hook but we can make templates and easily add them to existing repos: http://stackoverflow.com/questions/2293498/git-commit-hooks-global-settings
#unalias gco 2>/dev/null
#gco() {
#	# highlighting stderr here is useless, because git reports success on stderr too!
#	git checkout "$@"
#	local ret_status="$?"
#
#	if [ "$ret_status" = 0 ] && [ -n "$POST_GIT_CHECKOUT" ]
#	then eval "$POST_GIT_CHECKOUT"
#	fi
#
#	# I find I don't always notice failed checkouts, because at a glance the warning message looks similar to the success message.
#	if [ "$ret_status" != 0 ]
#	then echo "$(tput setaf 1 ; tput bold)FAILED$(tput sgr0)" >/dev/stderr
#	fi
#
#	return "$ret_status"
#}
#
## Primarily I use POST_GIT_CHECKOUT to run cindex whenever I change branch
#POST_GIT_CHECKOUT="$POST_GIT_CHECKOUT ; update_cindex"
#if ! which ionice >/dev/null
#then
#	ionice() {
#		"$@"
#	}
#fi
#update_cindex() {
#	# If CSEARCHINDEX is set (to an absolute or relative folder) then use that,
#	# otherwise use the default file in HOME folder.
#	# CONSIDER: If we are in a repo subfolder but the repo root folder contains a ".csearchindex" then we could point CSEARCHINDEX at that file temporarily.
#	if which cindex >/dev/null && ( [ -z "$CSEARCHINDEX" ] && [ -f "$HOME"/.csearchindex ] || [ -n "$CSEARCHINDEX" ] && [ -f "$CSEARCHINDEX" ] )
#	then
#		local git_root_folder="$(git rev-parse --show-toplevel)"
#		# If any of the indexed folders are equal to or below this project's folder
#		if [ -n "$git_root_folder" ] && cindex -list | grep -q "^$git_root_folder\($\|/\)"
#		then
#			echo "Updating cindex (in the background)"
#			# We do this in a separate shell in order to disable the tardy job completion message.
#			(
#				[[ -n "$ZSH_NAME" ]] && unsetopt MONITOR
#				nice ionice cindex 2>/dev/null &
#			)
#		fi
#	fi
#}

# TODO: There are a number of other occasions when cindex should be run, e.g. after a pull, reset or file save!  Perhaps it would be better if any programs which use csearch should just run cindex every time before they run csearch.  That should still be faster than grep!

# Git What Is Not Pushed (doesn't always work - I use gbs more often)
# I very rarely use this these days, because my git-status-prompt tells me how many local commits need to be pushed.
alias gwinp=gwinpsh
#alias gwinpsh='gll @{upstream}..HEAD'
alias gwinpsh='gll "$(git_guess_upstream_branch)..HEAD"'
# Git What Is Not Pushed Log
alias gwinpshl='gl "$(git_guess_upstream_branch)..HEAD"'
# Git What Is Not Pushed Files
alias gwinpshf='glf "$(git_guess_upstream_branch)..HEAD"'
# Git What Is Not Pushed Diff
alias gwinpshd='gd "$(git_guess_upstream_branch)..HEAD"'

# Shortcuts I never used
## Git To Push
#alias gtp='gwinp'
## Git To Push Log
#alias gtpl='gwinpd'
## Git To Push Files (often works poorly since it compares against FETCH_HEAD)
#alias gtpf='git topush'
## Git To Push Details / Diff (a direct diff, without listing each commit)
#alias gtpd='gwinpd'

# Usually my @{upstream} is where I push to, but not where I pull from.
# So I need to specify where I will pull from:
#[ -z "$remote_upstream_branch" ] && remote_upstream_branch="origin/master"
#[ -z "$remote_upstream_branch" ] && remote_upstream_branch="origin/main"
[ -z "$remote_upstream_branch" ] && remote_upstream_branch="origin/develop"

alias grm='git rm'
alias gmv='git mv'

# Git What Is Not Merged
alias gwinm='gll "HEAD..${remote_upstream_branch}"'
# Git What Is Not Merged Log
alias gwinml='gl "HEAD..${remote_upstream_branch}"'
# Git What Is Not Merged Files
alias gwinmf='glf "HEAD..${remote_upstream_branch}"'
# Git What Is Not Merged Diff
alias gwinmd='gd "HEAD..${remote_upstream_branch}"'

# Git What Is Not Pulled (alias for Merged)
alias gwinpl=gwinm
alias gwinpll=gwinml
alias gwinplf=gwinmf
alias gwinpld=gwinmd

alias gss='git stash save'
alias gssu='git stash save --include-untracked'
# -p lets us choose which hunks to stash
alias gssp='git stash -p'
#alias gsp='git stash pop'
# Sometimes popping the state results in conflicts because I was popping onto the wrong branch.  I can reset to restore the files, but then I will have lost my stashed changes, because they were popped!
# So git_stash_pop_safe will only drop the stash if it was successfully applied with no conflicts.
git_stash_pop_safe() {
	git stash apply "$@" &&
	git stash drop "$@"
}
alias gsp='git_stash_pop_safe'
alias gsa='git stash apply'
#alias gsl='git stash list'
#alias gsl='git stash list --date=relative --oneline'
# All this just adds the date to the normal git stash list:
alias gsl='git stash list --date=relative --oneline | PADDING=0 DELIM=" " numbereachline | sedreplace "^\([0-9]*\)" "stash@{\1}" | sedreplace "refs/stash@" "" | dropcols 2 | less -REX'
#alias gsl='git stash list --format=format:"%C(yellow bold)commit %H%C(magenta bold)%d%C(reset)%nAuthor: %an <%ae>%nDate:   %ad%n%n    %C(black bold)%s %C(reset)%C(yellow)%Creset%n"'
# Git Stash Diff shows the diff of the topmost or specified stash.  Notably not `git stash drop` which must be typed in full, to avoid doing it too easily and accidentally.
# This shows only the diff:
#alias gsd='git stash show -p'
# This shows the log and other header info too:
alias gsd='git show stash@{0}'
# Git Stash (diff) Files shows the files changed (like --stat)
alias gsf='git stash show'
# Git Stash List Diffs: lists all stashed commits, displaying their diffs
# This was bailing out with an error in zsh 5.0.2 when I was trying to start Fluxbox.
#gsld() {
#	# We must use an array if we want to expand the words later in zsh; an array requires local on a separate line
#	local stashes
#	stashes=($(git stash list | cut -d ':' -f 1))
#	local commit_id
#	for commit_id in "${stashes[@]}"
#	do git -c color.diff=always show "$@" "${commit_id}"
#	done |
#	less -R +'/(^commit .*|^diff .*)'
#}
# So here is a safer version
gsld() {
	(
		# We run in a subshell so that we can do this without affecting the outer environment
		# Most shells will expand the unquoted $stashes below, zsh needs a nudge in order to do that
		if [ -n "$ZSH_NAME" ]
		then setopt SH_WORD_SPLIT
		fi
		# We must use an array if we want to expand the words later in zsh; an array requires local on a separate line
		local stashes
		stashes="$(git stash list | cut -d ':' -f 1)"
		local commit_id
		for commit_id in $stashes
		do git -c color.diff=always show "$@" "${commit_id}"
		done |
		less -R +'/(^commit .*|^diff .*)'
	)
}
alias gsdrop='git stash drop'

# Use this to remove (reset) selected patches of uncommitted code.  Finer grained than `git reset` or `git checkout --` and also interactive.
# Answer "yes" to the hunks you want to remove/kill.
# How does it work?  It stashes the few patches you select, and then drops that new stash from the stash list.
# This affects the working tree, and thus is different from `git reset -p` which affects the index.
# Apart from leaving a dropped stash in the garbage, it has the same functionality to the built-in `git checkout -p` (gcop).
# Because the stash is dropped from the list, it is difficult to recover in case of an accident, but possible using `git-list-dropped-stashes` to search for the recently dropped commit.
git_kill_patch() {
	# If there are selections available, but none of them are selected, git stash -p will exit with code 1, so we know we don't need to drop.
	# But if there are _no changes available_ to stash, git stash -p will immediately exit with code 0, and then we would proceed to drop whatever unrelated stash is at the top of the stack!
	# To prevent that from happening, we abort early if there are no changes available to stash.
	if ! git diff | grep . >/dev/null && ! git diff | grep . >/dev/null
	then
		echo "There are no changes to kill"
		return
	fi

	gssp &&
	git stash drop
}
#alias gkp='git_kill_patch'
# I remember it as Git Stash Save Kill
alias gssk='git_kill_patch'

# Apply a stash even if there are uncommitted changes in some of the affected files
git_stash_apply_merge() {
	# joeytwiddle's technique
	#git commit -a -m 'TEMPORARY COMMIT' &&
	#git stash apply "$@" &&
	#git reset HEAD~
	# iFreilicht's technique:
	local git_root_folder="$(git rev-parse --show-toplevel)"
	git add -u "$git_root_folder" &&
	git stash apply "$@" &&
	git reset
}
alias gsam='git_stash_apply_merge'
alias gsaf='git_stash_apply_merge'

# Pop a stash even if there are uncommitted changes in some of the affected files
git_stash_pop_merge() {
	git_stash_apply_merge "$@" &&
	git stash drop
}
alias gspm='git_stash_pop_merge'
alias gspf='git_stash_pop_merge'

alias gsi='git submodule init'
alias gsu='git submodule update'

# Like git clone but shows the username in the target directory
# I no longer enjoy using this, because I care more about tab-completion of the project name than the author's name.  If there are separate repos with the same name, why not just put them all in one folder as different remotes?
git_clone_friendly() {
	if [ $# -gt 1 ]
	then git clone "$@"
	else
		local url="$1"
		# username.repo
		#local folder="$(printf "%s\n" "$1" | sed 's+/$++' | grep -o "[^/]*/[^/]*$" | tr '/' '.')"
		# repo
		local folder="$(printf "%s\n" "$1" | sed 's+/$++' | grep -o "[^/]*$")"
		git clone "$url" "$folder" &&
		cd "$folder"
	fi
}
#alias gcl='git_clone_friendly'
alias gcl='git clone'

# Git Auto Commit, or Git Add Commit, or Git Add and Commit
gac() {
	git add "$@"
	echo -n "Commit message: "
	read msg
	git commit -m "$msg"
}

if ! which verbosely >/dev/null
then
	verbosely() {
		printf "%s\n" "[EXEC] % $*" >&2
		"$@"
	}
fi

# Git Branch by Date
git_branch_by_date() {
	local reset_color="$(tput sgr0 | sed 's/$//')"
	# Optional
	local subject_color="$(tput setaf 0 ; tput bold)"
	local author_color="$(tput setaf 6)"

	local target=refs/heads
	#local commit_color="$(git config --get-color color.diff.commit yellow)"
	if [ "$1" = -r ]
	then
		#target=refs/remotes/origin
		target=refs/remotes
		#branch_color="$(git config --get-color color.branch.remote red)"
	fi

	# %(committerdate:iso8601)
	git for-each-ref --sort=committerdate $target --format="%(refname:short) ${author_color}%(committerdate:relative) (%(authorname)) -${reset_color} ${subject_color}%(subject)${reset_color}"
}

# Git Branch by Date wrapper
gbd() {
	# In tmux, reset_color gets an extra `^O` on the end, which the terminal ignores, but which will show up if output is piped to less.  It happens when TERM=screen or screen-256color, but it goes away if we set TERM=xterm.  For now we will just strip that trailing `^O` char.
	local reset_color="$(tput sgr0 | sed 's/$//')"
	local current_branch_color="$(git config --get-color color.branch.current green)"
	local branch_color="$(git config --get-color color.branch.local white)"

	# TODO: Parse args in no particular order, and show help, like gbs does
	# CONSIDER: Decide whether or not to show_color based on terminal type, and arguments

	# For quick results, we show just one page of history by default
	local count="$((LINES-2))"
	# but if the user is piping (e.g. to grep), then we should search further back (but not too far because a lot of branches can make -M very slow)
	if [ ! -t 1 ]
	then count=500
	fi
	local showancestors=''
	if [ "$1" = "-M" ]
	then showancestors="yes" ; shift
	fi
	if [ "$1" = "-n" ]
	then count="$2"; shift; shift
	fi

	local need_pager=
	if [ $count -gt "$((LINES-2))" ]
	then need_pager=1
	fi

	current_branch="$(git_get_current_branch)"

	git_branch_by_date "$@" |
	tail -n "${count}" |
	while read refname rest
	do
		local local="${refname}"

		## NOTE: This code is cloned from gbs.  Can we refactor it out?
		if [ "$local" = "$current_branch" ]
		then preBranch="* "
		else
			preBranch=". "
			if [ -n "$showancestors" ]
			then
				local_branch_commit_hash="$(git rev-parse --verify "$local")"
				common_commit_between_branch_and_current="$(git merge-base "$local" "$current_branch")"
				if [ "$common_commit_between_branch_and_current" = "$local_branch_commit_hash" ]
				then preBranch="| "
				else preBranch="/ "
				fi
			# I considered using "+" and "-" instead, but these are harder to visually distinguish from "*" and each other.
			# Another alternative I tried was "~" and "x", but again the "*" is easily lost there.
			fi
		fi

		echo "${preBranch}${refname} ${rest}"
	done |

	if which columnise-clever >/dev/null
	then columnise-clever -ignore '[^ ]* *[^ ]* *[^ ]*'
	else cat
	fi |
	replace_ancestor_markers_with_colors |
	if [ -n "$need_pager" ]
	then
		# -R=show_colors -X=no_clear -S=chop_long_lines +G=jump_to_end
		less -R -X -S +G
		#more -R   # (since more=less on Mac; fails on Linux)
	else
		# -E=quit_at_end (in other words this just chops long lines)
		less -R -E -X -S +G
		#cat
	fi
}
alias gbdr='gbd -r'

# May rename "gitsummary"
gitwhatsup() {
	echo
	# Absolute path:
	local gitDir=$(git rev-parse --git-dir)
	# On some systems, gives relative path:
	#local gitDir=$(git rev-parse --git-dir)
	local greenBackground=$(tput setab 2)
	local whiteForeground=$(tput setaf 7)
	#echo "${greenBackground}${whiteForeground}$(cursebold)GITDIR:$(tput init) $gitDir"
	echo "$(cursecyan)=== Git directory ===$(cursenorm)"
	echo "$gitDir"
	echo
	#echo "$(cursecyan)$gitDir$(cursenorm)"
	#echo "${greenBackground}${whiteForeground}$(cursebold)$gitDir$(tput init)"
	echo "$(cursecyan)=== Remotes ===$(cursenorm)"
	git remote -v #| prepend_each_line "   "
	echo "(For more details, run: git remote show <remote>)"
	echo
	echo "$(cursecyan)=== Local branches ===$(cursenorm)"
	git branch -vv #| prepend_each_line "   "
	echo
	echo "$(cursecyan)=== Remote branches ===$(cursenorm)"
	git branch -r -vv #| prepend_each_line "   "
	echo
	echo "$(cursecyan)=== Not yet pushed ===$(cursenorm)"
	gll "@{u}..HEAD" | cat
	echo
	echo "$(cursecyan)=== Current branch is tracking ===$(cursenorm)"
	git rev-parse --abbrev-ref --symbolic-full-name @{u}
	echo
	# Try `git remote update` if you can't see all the remote branches
}
alias gwu=gitwhatsup

# Guesses the name of the upstream branch, given the local branch name (or no arguments, which assumes current branch)
git_guess_upstream_branch() {
	# CONSIDER: This might be a simpler solution: git for-each-ref --format='%(upstream:short)' "$(git symbolic-ref -q HEAD)"

	local local_branch remote_branch remote_commit
	# No problem if this arg is empty, it will work fine for the current branch anyway
	local_branch="$1"
	# First guess
	remote_branch="$local_branch@{upstream}"
	# Check if it exists
	# We cannot use --symbolic or --abbrev-ref here; it will return what was given even if no upstream exists.
	# In fact we must specify --revs-only to prevent that from occurring!
	# We hide the error if the remote branch is not found.
	# BUG: On git 1.8.5.2 on MacOSX, we are getting remote_commit='a_long_hash_id'  I was hoping it would be empty, so we could at least guess a symbolic remote branch.
	remote_commit=$(git rev-parse --revs-only "$remote_branch" 2>/dev/null)
	if [ -z "$remote_commit" ]
	then
		# If no upstream was set, guess a branch on "origin" with the same name.  TODO: if "origin" does not exist, can we make a better guess?
		# Before we can do that, we may need a name for the local branch, if none was provided
		if [ -z "$local_branch" ]
		then local_branch=$(git_get_current_branch)
		fi
		remote_branch="origin/$local_branch"
		# Check if it exists (we could have probably done this the same way we used earlier)
		if ! git branch --list -r "$remote_branch" | grep . >/dev/null
		then remote_branch=""
		fi
	fi
	echo "$remote_branch"
}

vim_for_git_logs() {
	# Our mappings use z<CR> to scroll so the cursor is at the top of the window after n/N search
	# I tried setting scrolljump=-99 and got a screen jump when going of the bottom, but only half when going off the top.
	local vim_exe=vim
	#local vim_exe=gvim
	"$vim_exe" +'setlocal nomodified nomodifiable filetype=git foldmethod=syntax foldcolumn=2' \
	    +'/^\(commit\|diff --git\|diff --combined\) .*' \
	    +'normal gg' \
	    +'highlight clear Search' \
	    +'"When seeking, scroll destination line to top of screen' \
	    +'set scrolloff=0' \
	    +'nnoremap n nzt' \
	    +'nnoremap N Nzt' \
	    +'"But when the user performs a custom search, undo the above mappings' \
	    +'nnoremap / :nunmap n<CR>:nunmap N<CR>:nunmap /<CR>/' \
	    "$@"
	    #+'set nohlsearch' \
}

vim_for_git_logs_from_stdin() {
	#cat > /tmp/vim_for_git_logs.out
	#vim_for_git_logs "$@" /tmp/vim_for_git_logs.out
	vim_for_git_logs "$@" -
}

# Git Log in Vim
glv() {
	local count=50
	if [ "$1" = -n ]
	then
		count="$2"
		shift
		shift
	fi
	git log -p -n "$count" "$@" | vim_for_git_logs_from_stdin
}

# Git Diff in Vim
gdv() {
	git diff | vim_for_git_logs_from_stdin
}

# To delete local branches which have been merged into master:
#   git branch --merged master | grep -v "\* master" | xargs -n 1 git branch -d

git_branch_status() {
    # Original: https://gist.github.com/Mark-Booth/5058384
    # Active: https://github.com/bill-auger/git-branch-status
    # This version by joeytwiddle was forked from the original
    # Similar functionality can be had from: git branch -vv | highlight -bold '\<behind\> [0-9]*' red | highlight -bold '\<ahead\> [0-9]*' green

    # Displays your git branches with a summary of how many commits ahead or behind the local is from its remote branch.
    # Also displays (through color/labels) which branches are ancestors of (have already been merged into) the current branch.

    # If no upstream is set for a branch, it will guess a branch with the same name on origin.
    # Use the 'gbs' alias wrapper below for colors and column alignment.

    # example:
    # $ git branch-status -a
    # dns_check (ahead 1) | (behind 112) origin/master
    # master (ahead 2) | (behind 0) origin/master
    # $ git branch-status
    # master (ahead 2) | (behind 0) origin/master

    # Surely this was a non-local variable leaking out of git_branch_status and has already been fixed.
    # BUG (fixed?): Running gbs after git_branch_status -a -v gives only 1-line output.  Steps to reproduce:
    # Use Mac.  Start jsh in bash (with GNU coreutils etc.).  See gbs works fine.  Now do git_branch_status -a -v, also works fine.
    # Now see gbs only displays one line!
    # From initial tracing, it appeared that the final gbs call only iterates once during the while getopts.
    # Since we need both -v and -a to show more than one line here, we saw only one line.

    local usage option filter OPTARG compareto showancestors verbose branch_name_regexp

    local current_branch local remote DELTAS LEFT_AHEAD RIGHT_AHEAD preBranch guessed_remote
    local local_branch_commit_hash common_commit_between_branch_and_current abstatus

    local sorting=

    usage="git_branch_status [-hamtMv] [<branch_name_regexp>] -- summarise status of branch(es)

where:
    -h           show this help text
    -a           show all branches, not just the current one
    -m           shows branch(es) with respect to origin/master
    -t <branch>  shows branch(es) with respect to given branch
    -d           sort by date (default is to sort by name)
    -M           indicates branches which have been merged into current
    -v           verbose, show output even if counts are zero"

    while getopts 'hamt:pdMv' option; do
      case "$option" in
        h) echo "$usage"
           return # exit
           ;;
        a) filter=refs/heads
           ;;
        m) compareto=origin/master
           ;;
        t) compareto="$OPTARG"
           ;;
        d) sorting="--sort=committerdate"
           ;;
        M) showancestors=true
           ;;
        v) verbose=true
           ;;
        ?) printf "illegal option: '%s'\n" "$OPTARG" >&2
           echo "$usage" >&2
           return # exit 1
           ;;
      esac
    done
    shift "$((OPTIND - 1))"

    # If we call a getopts from a function, it may change the value of OPTIND.  We need to reset it to the default (1), or future calls to getopts will start looking at the wrong argument!  (Needed for bash 3.2.57 at least.  Reproduce with two calls from an interactive shell, e.g. `git_branch_status -a -v`, and notice the arguments are ignored on the second call.)
    OPTIND=1

    branch_name_regexp="$1"
    if [ -n "$branch_name_regexp" ]
    then filter=refs/heads
    fi

    if [ -z $filter ] ; then
        filter=$(git symbolic-ref -q HEAD)
    fi

    current_branch="$(git_get_current_branch)"

    git for-each-ref $sorting --format="%(refname:short) %(upstream:short)" $filter |
    grep -e "$branch_name_regexp" |
    while read local remote
    do
        if [ -n "$compareto" ] ; then
            remote="$compareto"
        fi
        #[ -z "$remote" ] && continue
        # This is an assumption I made for our project - that if a branch does not have an upstream set, then we should assume the upstream is a branch on 'origin' with the same name.
        # It could be avoided if we used --track when initially creating the local branch with git branch or git checkout.  Tracking can also be setup retrospectively with `git branch -u <remote_branch>` in Git > 1.8.0 or `git branch --set-upstream <local_branch> <remote_branch>` in Git > 1.7.0.
        guessed_remote=""
        if [ -z "$remote" ]
        then
           guessed_remote=" ?"
            # If no upstream has been set, assume a remote branch with the same name
            remote="origin/$local"
            if ! git branch --list -r "$remote" | grep . >/dev/null
            then
                # No remote branch exists
                remote=""
                guessed_remote=""
                # But if this is the current branch, or we are in verbose mode, we might still like to display it anyway.
                # However ahead/behind counts are meaningless without a remote.
                if [ "$local" = "$current_branch" ] || [ -n "$verbose" ]
                then :
                else continue
                fi
            fi
        else
          # Sometimes the remote branch may have been removed, but the local branch is still trying to track it
          if ! git rev-parse "$remote" >/dev/null 2>&1
          then
            echo "Remote branch no longer exists: $remote" >&2
            remote=""
          fi
        fi
        # If we do not have a remote to compare to, display no counts, rather than relative to current branch, which is quite arbitrary (but can be achieved using $compareto if desired).
        if [ -n "$remote" ]
        then DELTAS=$(git rev-list --left-right "${local}...${remote}")
        else DELTAS=""
        fi
        LEFT_AHEAD=$(echo "$DELTAS" | grep -c '^<')
        RIGHT_AHEAD=$(echo "$DELTAS" | grep -c '^>')

        if [ "$local" = "$current_branch" ]
        then preBranch="* "
        else
            preBranch=". "
            if [ -n "$showancestors" ]
            then
                # We can actually get a list of merged branches from: git branch --merged $current_branch
                # http://devblog.springest.com/a-script-to-remove-old-git-branches/
                local_branch_commit_hash="$(git rev-parse --verify "$local")"
                common_commit_between_branch_and_current="$(git merge-base "$local" "$current_branch")"
                if [ "$common_commit_between_branch_and_current" = "$local_branch_commit_hash" ]
                then preBranch="| "
                else preBranch="/ "
                fi
                # I considered using "+" and "-" instead, but these are harder to visually distinguish from "*" and each other.
                # Another alternative I tried was "~" and "x", but again the "*" is easily lost there.
            fi
        fi

        if [ -n "$verbose" ] || [ "$LEFT_AHEAD" -gt 0 ] || [ "$RIGHT_AHEAD" -gt 0 ] || [ "$local" = "$current_branch" ] ; then
            if [ -z "$remote" ]
            then abstatus="(none)"
            else abstatus="(ahead $LEFT_AHEAD) | (behind $RIGHT_AHEAD)"
            fi
            echo "$preBranch$local $abstatus $remote$guessed_remote"
        fi
    done
}
gbs() {
  # A wrapper for git_branch_status that adds color.
  # Displays status of current branch relative to upstream and downstream versions
  # With no arguments, inspects all branches
  # With argument `.`, displays current branch
  # With any other argument, uses that as the branch name
  # If the branch has no upstream (pull) specified, then assume origin/<branch_name> if it exists, otherwise assume origin/master
  # If the branch has no downstream (push) specified, then assume origin/<branch_name>
  # This may help: http://stackoverflow.com/questions/2969214/git-programmatically-know-by-how-much-the-branch-is-ahead-behind-a-remote-branc
  # git branch -v can partially do this already.  It shows e.g. [behind 12] after the commit hash but before the message.  Unfortunately it has no color and does not stand out very well.
  # Or perhaps better: https://gist.github.com/jehiah/1288596 (from http://stackoverflow.com/questions/7773939/show-git-ahead-and-behind-info-for-all-branches-including-remotes )

  local show_color
  local color_setting="$(git config --get color.ui)"
  if [ "$color_setting" = 'true' ] || [ "$color_setting" = 'auto' ] && [ -t 1 ]
  then show_color=true
  fi

  if [ "$1" = . ]
  then shift ; git_branch_status "$@"
  else git_branch_status -a -v $GBS_OPTIONS "$@"
  fi |
  column -s ' ' -t | sed 's+ \( *\)+\1+g' |
  #columnise |
  if [ -n "$show_color" ]
  then
    # We should probably only do this jazz if $() = 'true' or = 'auto' && [ -t 1 ]
    local reset_color="$(tput sgr0)"
    local ahead_color="$(tput setaf 2 ; tput bold)"    # green
    local behind_color="$(tput setaf 1 ; tput bold)"   # red
    # Git's default remote branch color is red, but that conflicts with behind_color, so I have set it to 'white' here.
    local remote_branch_color="$(git config --get-color color.branch.remote white)"
    sed "
      s+\()  *\)\([^ ]*\)$+\1$remote_branch_color\2$reset_color+
      s+(ahead *[1-9][0-9]*)+$ahead_color\0$reset_color+
      s+(behind *[1-9][0-9]*)+$behind_color\0$reset_color+
    " |
    replace_ancestor_markers_with_colors
  else cat
  fi
}
# git branch status by "date": most recent last
alias gbsd='gbs -d'
# git branch status "long": show all the details, takes longer
alias gbsl='gbs -dM'
# Alternatively, to get this all the time, you could do:
#   export GBS_OPTIONS='-d -M'

replace_ancestor_markers_with_colors() {
	# BUG TODO: In bash 4.4.12(1)-release on Mac OS X (installed via homebrew) the following three lines cause the script to background itself!
	#           Perhaps git config is attempting some I/O and breaking out because it is running inside a pipe
	local current_branch_color="$(git config --get-color color.branch.current green)"
	local local_branch_color="$(git config --get-color color.branch.local white)"
	local ancestor_branch_color="$(git config --get-color color.branch.ancestor cyan)"
	sed "
		s+^[*] *\([^ ]*\)+* $current_branch_color\1$reset_color+
		s+^[./x-] *\([^ ]*\)+  $local_branch_color\1$reset_color+
		s+^[\\+|] *\([^ ]*\)+  $ancestor_branch_color\1$reset_color+
	"
}

git_get_current_branch() {
	# symbolic-ref fails during an incomplete rebase with `fatal: ref HEAD is not a symbolic ref`
	# It can also fail on git 1.7 with "unknown option `short`"
	#git symbolic-ref --short HEAD
	# rev-parse does not fail, but responds with "HEAD" instead of the branch name.
	#git rev-parse --abbrev-ref HEAD
	# So for git 1.7 we do:
	local current_branch="$(git rev-parse --abbrev-ref HEAD)"
	if [ "$current_branch" = HEAD ]
	then
		echo "git rev-parse got branch name: HEAD" >&2
		# Scripts might assume this value is correct.  For them, we make it obvious it is not!
		echo "__NO_BRANCH_NAME_FOUND__"
		return 1
	else
		echo "$current_branch"
		return 0
	fi
}

git_list_all_tracked_files() {
	# Accepts a branch name or commit id

	# Version using ls-files.  (I don't see any advantage to this version.)
	# - Shows files under current directory, not all files in repo (unless you are in root directory, or pass the root directory as the second argument).
	# - Does not work on bare repos.
	#local tree_arg=''
	#if [ -n "$1" ]
	#then tree_arg="--with-tree=$1"; shift
	#fi
	#git ls-files $tree_arg "$@"

	# Alternative version, using ls-tree instead of ls-files.
	local tree=HEAD
	if [ -n "$1" ]
	then tree="$1"; shift
	fi
	git ls-tree -r --name-only --full-tree "$tree" "$@"
}

# Previously called: git_find_branch_start_commit
# Could also be called: git_find_common_commit
git_find_base_commit() {
	local other_branch current_branch

	# It is more likely we want to compare the current branch against an alternative, than to compare an alternative against master.  So we accept the alternative first.
	if [ -n "$1" ]
	then other_branch="$1"
	else other_branch=master
	fi

	# But user may specify the "current" branch second if they wish
	if [ -n "$2" ]
	then current_branch="$2"
	else current_branch="$(git_get_current_branch)"
	fi
	# Although the order doesn't really matter when passing 2 arguments, since merge-base is symmetric!

	# This is not guaranteed, but the information is likely still in the cache if the branch was created in the last 90 days.
	# In fact it completely fails if you have pulled the branch from a remote repository.  It shows the HEAD at the time that you pulled!
	#git reflog show $current_branch | tail -n 1

	git merge-base "$other_branch" "$current_branch"
}

git_show_base_commit() {
	local commitId="$(git_find_base_commit "$@")"

	if [ -n "$commitId" ]
	then
		# These vars have disappeared inside the refactored function :P
		#echo "$current_branch and $other_branch share common commit:"
		#git log --pretty=oneline -1 "$commitId"
		glc -1 "$commitId"
	fi
}

git_in_root_dir() {
	(
		git_root_folder="$(git rev-parse --show-toplevel)"
		cd "${git_root_folder}"
		"$@"
	)
}

# This basically works like --autostash
# If you have unstashed changes, it stashes them, then it runs the given command, and then it unstashes them.
git_do_with_changes_stashed() {
	local stashed_commit="$(git stash create)"
	git reset --hard
	if [ -n "${stashed_commit}" ]
	then echo "Created tempstash: ${stashed_commit}"
	fi

	"$@"

	if [ -n "${stashed_commit}" ]
	then
		git stash apply --quiet "${stashed_commit}"
		echo "Restored tempstash."
	fi
}
alias git_autostashed=git_do_with_changes_stashed
alias git_stashed=git_do_with_changes_stashed

git_create_empty_branch() {
	local git_root_folder=$(git rev-parse --show-toplevel)
	git checkout --orphan empty &&
	git reset --hard &&
	git commit --allow-empty -m "== Empty commit =="
}

git_list_submodule_urls() {
	git submodule foreach -q git config remote.origin.url
}

# `git remote prune origin [--dry-run]` is faster than `git fetch --prune`

# If `git blame` is not going back far enough, consider using `git log -S<search_string>` or `git log -L<start_line>,<end_line>`

# From qswz on FreeNode
#alias gco='git checkout'
# with this (for bash)
#complete -W '$(git for-each-ref --format="%(refname:short)" | grep -v origin/HEAD)' -o bashdefault -o default gco

git_cd_to_toplevel() {
	local git_root_folder
	git_root_folder="$(git rev-parse --show-toplevel)" &&
	cd "${git_root_folder}"
}
# Wait and see which of these I end up using, then remove the others
alias gcdtl='git_cd_to_toplevel'
alias cdgtl='git_cd_to_toplevel'
alias cdgitroot='git_cd_to_toplevel'
alias cdgr='git_cd_to_toplevel'
alias cd_gitroot='git_cd_to_toplevel'
alias cd_git_toplevel='git_cd_to_toplevel'

alias gclean='git clean'
alias gcleani='git clean -i'
alias gcleanuntracked='git clean -di'
alias gcleanignored='git clean -dXi'
alias gcleanall='git clean -dxi'

# vim: ft=sh
