# TODO: Turn these into shellscripts so they are available from vim's command line.
#       Put them somewhere and load them onto the PATH optionally.  (Not everyone will want them.)

# I tried declaring functions as `'name'()` instead of just `name()` to avoid existing aliases (e.g. those in oh-my-zsh's git plugin) from causing trouble by expanding the name.  An alternative is to use `function name()` but that may be less compatible with older shells.  OK well `'name'()` is incompatible with bash already!  Now trying unalias...
# TODO: I should really do this *everywhere* I declare functions in jsh?!

#alias gs='git status'
#alias gs='gitstatus'
#alias gs='if [ -t 1 ]; then gitstatus | more; else git status; fi'
#function gs() {
#	if [ -t 1 ]
#	then gitstatus "$@" | more
#	else git status "$@"
#	fi
#}
unalias gs 2>/dev/null
gs() {
	# Show color if not piping.  Skip to next section on 'n'.  Leave output on screen (so user can copy paste).
	# Using more instead of less because on short output, less fills the rest of the screen with '~'s (or ''s) we don't need.  Those lines are actually caused by the search.  git's default 'pager' will do the same iff the +/ is added.
	# More has slightly different searching behaviour than less: it will not skip to the start of a section which is already visible on the screen.
	# -X tells less to leave its output on the screen
	# This now now rather equivalent to the default, except for the default search.
	if [ -t 1 ]
	then
		git -c color.status=always status "$@" |
		more
		# The problem with doing this search with more is that more skips the first "branch" line, even though it is a match.  And it does not even allow paging up to find it!
		#more +'/^# [^ ].*'
		#less -R +'/^# [^ ].*' -E -X --tilde
		#pager -R +'/^# [^ ].*' -E -X --tilde
	else git status "$@"
	fi
}

#alias gd='git diff'
unalias gd 2>/dev/null
gd() {
	# Show color if not piping.  Skip to next file on 'n'.
	if [ -t 1 ]
	then git -c color.diff=always diff "$@" | less -R +'/^diff.*' -X
	else git diff "$@"
	fi
}
alias gdw='git diff --word-diff'
# Git Diff Staged / Cached (see which one I use most ... I used gdc!)
#alias gds='gdc'
alias gdc='gd --cached'

alias ga='git add'
#alias gc='git commit'
alias gc='git commit -v'
alias gf='git fetch'
alias gp='git preview'
alias gw='git whatsnew'
alias gm='git merge FETCH_HEAD'

#alias gl='git log'
#alias gl='git log -U2 -p -m'
# I thought it might be nice to setup less so that we can jump to the next commit with 'n'
# Unfortunately whilst this provides the feature, git disables colors:
#   gl | less +"/^commit.*" -r
# Oh, fixed it.  Since this make paging commits very fast, now adding --stat
#alias gl='git -c color.ui=always log -U2 -p -m --stat | less -R "+/^commit.*"'
unalias gitlog 2>/dev/null
gitlog() {
	# Show color if not piping.  Skip to next file or commit on 'n'.
	if [ -t 1 ]
	then git -c color.ui=always log "$@" | less -R +'/^(commit|diff).*' -X
	else git log "$@"
	fi
}
alias gl='gitlog -U2 -p -m --stat'
# It is debatable whether we want to page through diffs or just whole commits; it kinda depends what the user is looking for that particular time!
alias glw='gl --word-diff'
# Just file stats, no diffs.  "Git log stats/summary", "Git log files" (shorter)
alias gls='gitlog --stat'
# If you want to use this with --graph then it should have a %n at the end.
alias glf='git log --stat --pretty=oneline --pretty=format:"%C(yellow bold)%h%C(magenta bold)%d%C(reset) %C(black bold)%s %C(reset)%C(cyan)- %an (%ar)%Creset"'
# With glf, we can walk commmits with /^[^ ]+
# Just commit info, one per line
#alias gll='git log --graph --decorate --pretty=oneline --abbrev-commit --all'
# Argh.  git lol in my .gitconfig is better because is shows the name of the committer.
#alias gll='git lol'
alias gll='git log --graph --pretty=format:"%C(yellow)%h%C(magenta bold)%d%C(reset) %C(black bold)%s %C(reset)%C(cyan)- %an (%ar)%Creset"'
# Git Log Summary (use glf?)
# Git Log Grey.  Like 'gl' except we present colors the same as in gll and glf
alias glg='gl --format=format:"%C(yellow bold)commit %H%C(magenta bold)%d%C(reset)%nAuthor: %an %ae%nDate:   %ad%n%n    %C(black bold)%s %C(reset)%C(yellow)%Creset%n"'

alias gb='git branch'
alias gco='git checkout'
alias gi='git commit --interactive'

# Git auto commit OR Git-add-commit
unalias gac 2>/dev/null
gac() {
	git add "$@"
	echo -n "Commit message: "
	read msg
	git commit -m "$msg"
}

# May rename "gitsummary"
unalias gitwhatsup 2>/dev/null
gitwhatsup() {
	echo
	# Absolute path:
	local gitDir=$(git rev-parse --show-toplevel)/.git
	# On some systems, gives relative path:
	#local gitDir=$(git rev-parse --git-dir)
	local greenBackground=$(tput setab 2)
	local whiteForeground=$(tput setaf 7)
	#echo "${greenBackground}${whiteForeground}$(cursebold)GITDIR:$(tput init) $gitDir"
	echo "`cursecyan`=== Git directory ===`cursenorm`"
	echo "$gitDir"
	echo
	#echo "`cursecyan`$gitDir`cursenorm`"
	#echo "${greenBackground}${whiteForeground}$(cursebold)$gitDir$(tput init)"
	echo "`cursecyan`=== Remotes ===`cursenorm`"
	git remote -v #| prepend_each_line "   "
	echo
	echo "`cursecyan`=== Local branches ===`cursenorm`"
	git branch -vv #| prepend_each_line "   "
	echo
	echo "`cursecyan`=== Remote branches ===`cursenorm`"
	git branch -r -vv #| prepend_each_line "   "
	echo
	echo "`cursecyan`=== Not yet pushed ===`cursenorm`"
	gll "@{u}..HEAD" | cat
	echo
	echo
	# Try `git remote update` if you can't see all the remote branches
}
alias gwu=gitwhatsup

# Git What Is Not Pushed
alias gwinp='gll FETCH_HEAD..HEAD'
# Git What Is Not Pushed Details
alias gwinpd='gl FETCH_HEAD..HEAD'
# Git To Push
alias gtp='gwinp'
# Git To Push Files
alias gtpf='git topush'
# Git To Push Log
alias gtpl='gwinpd'
# Git To Push Details / Diff (a direct diff, without listing each commit)
alias gtpd='gd FETCH_HEAD..HEAD'

git_branch_status() {
    # hosted at   https://gist.github.com/Mark-Booth/5058384
    # forked from https://gist.github.com/lth2h/4177524 @ ae184f1 by mark.booth
    # forked from https://gist.github.com/jehiah/1288596 @ e357c1e by lth2h
    # ideas from https://github.com/kortina/bakpak/blob/master/bin/git-branches-vs-origin-master

    # this prints out some branch status
    # (similar to the '... ahead' info you get from git status)

    # example:
    # $ git branch-status -a
    # dns_check (ahead 1) | (behind 112) origin/master
    # master (ahead 2) | (behind 0) origin/master
    # $ git branch-status
    # master (ahead 2) | (behind 0) origin/master

    local usage option filter originmaster verbose current_branch local remote DELTAS LEFT_AHEAD RIGHT_AHEAD preBranch

    usage="$(basename "$0") [-hav] -- summarise status of branch(es)

where:
    -h  show this help text
    -a  show all branches, not just the current one
    -m  shows branch(es) with respect to origin/master
    -v  verbose, show output even if counts are zero"

    while getopts 'hamv' option; do
      case "$option" in
        h) echo "$usage"
           exit
           ;;
        a) filter=refs/heads
           ;;
        m) originmaster=true
           ;;
        v) verbose=true
           ;;
        ?) printf "illegal option: '%s'\n" "$OPTARG" >&2
           echo "$usage" >&2
           exit 1
           ;;
      esac
    done
    shift $((OPTIND - 1))

    if [ -z $filter ] ; then
        filter=$(git symbolic-ref -q HEAD)
    fi

    current_branch=`git_get_branch_name`

    git for-each-ref --format="%(refname:short) %(upstream:short)" $filter | \
    while read local remote
    do
        if [ $originmaster ] ; then
            remote=origin/master
        fi
        #[ -z "$remote" ] && continue
        if [ -z "$remote" ]
        then
            # If no upstream has been set, we could guess a remote branch with the same name
            remote="origin/$local"
            if ! gb --list -r "$remote" | grep . >/dev/null
            then continue
            fi
        fi
        DELTAS=$(git rev-list --left-right ${local}...${remote})
        LEFT_AHEAD=$(echo "$DELTAS" | grep -c '^<')
        RIGHT_AHEAD=$(echo "$DELTAS" | grep -c '^>')
        if [ "$local" = "$current_branch" ]
        then preBranch="* "
        else preBranch=". "
        fi
        if [ $verbose ] || [ $LEFT_AHEAD -gt 0 ] || [ $RIGHT_AHEAD -gt 0 ] || [ "$local" = "$current_branch" ] ; then
            #echo "$local $WARN_LEFT(ahead $LEFT_AHEAD)$reset_color | $WARN_RIGHT(behind $RIGHT_AHEAD)$reset_color $remote"
            echo "$preBranch$local (ahead $LEFT_AHEAD) | (behind $RIGHT_AHEAD) $remote"
        fi
    done
}
gbs() {
  # A wrapper for git_branch_status that adds color.
  # Displays status of current branch relative to upstream and downstream versions
  # With no arguments, inspects all branches
  # With argument `.`, displays current branch
  # With any other argument, uses that as the branch name
  # If the branch has no upstream (pull) specified, then assume origin/<branch_name> if it exists, otherwise assume origin/master
  # If the branch has no downstream (push) specified, then assume origin/<branch_name>
  # This may help: http://stackoverflow.com/questions/2969214/git-programmatically-know-by-how-much-the-branch-is-ahead-behind-a-remote-branc
  # git branch -v can partially do this already.  It shows e.g. [behind 12] after the commit hash but before the message.  Unfortunately it has no color and does not stand out very well.
  # Or perhaps better: https://gist.github.com/jehiah/1288596 (from http://stackoverflow.com/questions/7773939/show-git-ahead-and-behind-info-for-all-branches-including-remotes )

  local reset_color=`tput sgr0`
  local ahead_color=`tput setaf 2 ; tput bold`
  local behind_color=`tput setaf 1 ; tput bold`
  # You can use the configured/default colors, but I quite like remote blank!  (The default red confuses behind_color.)
  local current_branch_color=`git config --get-color color.branch.current green`
  # I don't think anyone really wants color.  If you do, uncomment these:
  #local local_branch_color=`git config --get-color color.branch.local white`
  #local remote_branch_color=`git config --get-color color.branch.remote red`

  if [ "$1" = . ]
  then shift ; git_branch_status "$@"
  else git_branch_status -a "$@"
  fi |
  column -s ' ' -t | sed 's+ \( *\)+\1+g' |
  #columnise |
  #highlight -bold "(ahead *[1-9][0-9]*)" green |
  #highlight -bold "(behind *[1-9][0-9]*)" red |
  sed "
    s+(ahead *[1-9][0-9]*)+$ahead_color\0$reset_color+
    s+(behind *[1-9][0-9]*)+$behind_color\0$reset_color+
    s+^[*] *\([^ ]*\)+* $current_branch_color\1$reset_color+
    s+^[.] *\([^ ]*\)+  $local_branch_color\1$reset_color+
    s+[^ ]*$+$remote_branch_color\0$reset_color+
  "
}

git_get_branch_name() {
	git rev-parse --abbrev-ref HEAD
}

git_find_branch_start() {
	if [ -n "$1" ]
	then current_branch="$1"
	else current_branch=`git_get_branch_name`
	fi
	# This is not guaranteed, but the information is likely still in the cache if the branch was created in the last 90 days.
	# In fact it completely fails if you have pulled the branch from a remote repository.  It shows the HEAD at the time that you pulled!
	#git reflog show $current_branch | tail -n 1
	
	#other_branch=master
	other_branch=v3-alpha-stable
	git merge-base "$other_branch" "$current_branch"
}

