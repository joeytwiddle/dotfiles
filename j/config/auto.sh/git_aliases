# TODO: Turn these into shellscripts so they are available from vim's command line.
#       Put them somewhere and load them onto the PATH optionally.  (Not everyone will want them.)

# I had problems declaring functions whose name matched pre-existing aliases.  In my case this was when I was loading oh-my-zsh's git plugin before this script was sourced.
# Details: The function name was getting expanded into the alias during the declaration, either causing the declaration to fail syntactically, or to successfully silently declare the function using a different name!
# The behaviour I desired was to override his aliases with my own functions, but keep any of his aliases which did not conflict.
# The most sensible way to avoid expansion is to declare functions explicitly using `function name()` but some older shells do not recognize the `function` syntax, and I would like to support them.
# Another way to avoid expansion is to declare functions using `'name'()` instead of just `name()`.  This worked for zsh but not for bash.
# So finally I had to specifically unalias any function names which I *know* may be alaised elsewhere.
# This is all rather irrelevant now because I am no longer loading oh-my-zsh's git aliases.
unalias gs 2>/dev/null
unalias gd 2>/dev/null
unalias gitlog 2>/dev/null
unalias gac 2>/dev/null
unalias gitwhatsup 2>/dev/null
# Should I be doing this *everywhere* I declare a shell function in jsh, just in case an alias exists?!  No ... I just shouldn't load aliases I don't want!  :P

#alias gs='git status'
#alias gs='gitstatus'
#alias gs='if [ -t 1 ]; then gitstatus | more; else git status; fi'
#function gs() {
#	if [ -t 1 ]
#	then gitstatus "$@" | more
#	else git status "$@"
#	fi
#}
gs() {
	# Show color if not piping.  Skip to next section on 'n'.  Leave output on screen with -X (so user can copy paste).
	# Using more instead of less because on short output, less fills the rest of the screen with '~'s (or ''s) we don't need.  Those lines are actually caused by the search.  git's default 'pager' will do the same iff the +/ is added.
	# More has slightly different searching behaviour than less: it will not skip to the start of a section which is already visible on the screen.
	# This now rather equivalent to the default, except for the default search.
	if [ -t 1 ]
	then
		git -c color.status=always status "$@" |
		more
		# The problem with doing this search with more is that more skips the first "branch" line, even though it is a match.  And it does not even allow paging up to find it!
		#more +'/^# [^ ].*'
		#less -R +'/^# [^ ].*' -E -X --tilde
		#pager -R +'/^# [^ ].*' -E -X --tilde
	else git status "$@"
	fi
}

#alias gd='git diff'
gd() {
	# Show color if not piping.  Skip to next file on 'n'.
	if [ -t 1 ]
	then git -c color.diff=always diff "$@" | less -R +'/^diff.*' -X
	else git diff "$@"
	fi
}
alias gdw='git diff --word-diff'
# Git Diff Staged / Cached (see which one I use most ... I used gdc!)
#alias gds='gdc'
alias gdc='gd --cached'

alias ga='git add'
#alias gc='git commit'
alias gc='git commit -v'
alias gf='git fetch'
alias gp='git preview'
alias gw='git whatsnew'
alias gm='git merge FETCH_HEAD'

#alias gl='git log'
#alias gl='git log -U2 -p -m'
# I thought it might be nice to setup less so that we can jump to the next commit with 'n'
# Unfortunately whilst this provides the feature, git disables colors:
#   gl | less +"/^commit.*" -r
# Oh, fixed it.  Since this make paging commits very fast, now adding --stat
#alias gl='git -c color.ui=always log -U2 -p -m --stat | less -R "+/^commit.*"'
gitlog() {
	# Show color if not piping.  Skip to next file or commit on 'n'.
	if [ -t 1 ]
	then git -c color.ui=always log "$@" | less -R +'/^(commit|diff).*' -X
	else git log "$@"
	fi
}
# The regexp search allows us to quickly skip to the next diff or commit header by pressing `n`.  If you do not wish to jump through the diffs, you have two options:
#   1. Edit the search so it won't hit diff lines.  For example: `/<Left><Left><Left>z<Enter>`.  This will work for the rest of the session.
#   2. Count the number of files in this commit (as shown by --stat), add one, and jump that many times with e.g. `15n`.  This will work just once, so you can use `n` to skip diffs later.

# "Git Log Pure" - the basis for "Git Log Grey" but without colours
alias glp='gitlog -U2 -p -m --stat'
# Here --stat show a quick summary of changed files, before actually showing the diffs.  I rather enjoy this when using 'gl' as it lets me decide from the top of each commit whether there are any files I am interested in, and if not I can happily skip straight to the next commit.  In other situations, e.g. when I am planning to read all the details, --stat is just chaff.
# "Git Log Grey" - Like 'gl' except we present my favourite colors
alias glg='glp --format=format:"%C(yellow bold)commit %H%C(magenta bold)%d%C(reset)%nAuthor: %an %ae%nDate:   %ad%n%n    %C(black bold)%s %C(reset)%C(yellow)%Creset%n"'
# "Git Log" aliases to "Git Log Grey"
alias gl='glg'

# "Git Log Long" - One per line, with graph
#alias gll='git log --graph --decorate --pretty=oneline --abbrev-commit --all'   # Does not show committer's name or age of commit
#alias gll='git lol'
# Using the same colors as "Git Log Clear" except commits are not bold:
#alias gll='git log --graph --pretty=format:"%C(yellow)%h%C(magenta bold)%d%C(reset) %C(black bold)%s %C(reset)%C(cyan)- %an (%ar)%Creset"'
alias gll='glc --graph'
# "Git Log Long Minus merges"
alias gllm='gll --no-merges'

# "Git Log Clear" - Single lines, no graph.
# If you want to use this with --graph then it should have a %n at the end.  Actually I am not sure what that was for.
alias glc='git log --pretty=format:"%C(yellow bold)%h%C(magenta bold)%d%C(reset) %C(black bold)%s %C(reset)%C(cyan)- %an (%ar)%Creset"'

# "Git Log Word-diffed" - It is debatable whether we want to page through diffs or just whole commits; it kinda depends what the user is looking for that particular time!
alias glw='gl --word-diff'
# "Git Log Stats/Summary" - Just file stats, no diffs.
alias gls='gl --stat'
# "Git Log Files" - Compressed version of "Git Log Stats"
alias glf='glc --stat'
# With glf, we can walk commmits with /^[^ ]+
# Just commit info, one per line

alias gb='git branch'
alias gco='git checkout'
alias gi='git commit --interactive'

# Git auto commit OR Git-add-commit
gac() {
	git add "$@"
	echo -n "Commit message: "
	read msg
	git commit -m "$msg"
}

# May rename "gitsummary"
gitwhatsup() {
	echo
	# Absolute path:
	local gitDir=$(git rev-parse --show-toplevel)/.git
	# On some systems, gives relative path:
	#local gitDir=$(git rev-parse --git-dir)
	local greenBackground=$(tput setab 2)
	local whiteForeground=$(tput setaf 7)
	#echo "${greenBackground}${whiteForeground}$(cursebold)GITDIR:$(tput init) $gitDir"
	echo "`cursecyan`=== Git directory ===`cursenorm`"
	echo "$gitDir"
	echo
	#echo "`cursecyan`$gitDir`cursenorm`"
	#echo "${greenBackground}${whiteForeground}$(cursebold)$gitDir$(tput init)"
	echo "`cursecyan`=== Remotes ===`cursenorm`"
	git remote -v #| prepend_each_line "   "
	echo
	echo "`cursecyan`=== Local branches ===`cursenorm`"
	git branch -vv #| prepend_each_line "   "
	echo
	echo "`cursecyan`=== Remote branches ===`cursenorm`"
	git branch -r -vv #| prepend_each_line "   "
	echo
	echo "`cursecyan`=== Not yet pushed ===`cursenorm`"
	gll "@{u}..HEAD" | cat
	echo
	echo
	# Try `git remote update` if you can't see all the remote branches
}
alias gwu=gitwhatsup

# Git What Is Not Pushed
alias gwinp='gll FETCH_HEAD..HEAD'
# Git What Is Not Pushed Details
alias gwinpd='gl FETCH_HEAD..HEAD'
# Git To Push
alias gtp='gwinp'
# Git To Push Files
alias gtpf='git topush'
# Git To Push Log
alias gtpl='gwinpd'
# Git To Push Details / Diff (a direct diff, without listing each commit)
alias gtpd='gd FETCH_HEAD..HEAD'

git_branch_status() {
    # hosted at   https://gist.github.com/Mark-Booth/5058384
    # forked from https://gist.github.com/lth2h/4177524 @ ae184f1 by mark.booth
    # forked from https://gist.github.com/jehiah/1288596 @ e357c1e by lth2h
    # ideas from https://github.com/kortina/bakpak/blob/master/bin/git-branches-vs-origin-master

    # this prints out some branch status
    # (similar to the '... ahead' info you get from git status)

    # example:
    # $ git branch-status -a
    # dns_check (ahead 1) | (behind 112) origin/master
    # master (ahead 2) | (behind 0) origin/master
    # $ git branch-status
    # master (ahead 2) | (behind 0) origin/master

    local usage option filter OPTARG compareto verbose current_branch local remote DELTAS LEFT_AHEAD RIGHT_AHEAD preBranch

    usage="$(basename "$0") [-hav] -- summarise status of branch(es)

where:
    -h           show this help text
    -a           show all branches, not just the current one
    -m           shows branch(es) with respect to origin/master
    -t <branch>  shows branch(es) with respect to given branch
    -v           verbose, show output even if counts are zero"

    while getopts 'hamt:v' option; do
      case "$option" in
        h) echo "$usage"
           exit
           ;;
        a) filter=refs/heads
           ;;
        m) compareto=origin/master
           ;;
        t) compareto="$OPTARG"
           ;;
        v) verbose=true
           ;;
        ?) printf "illegal option: '%s'\n" "$OPTARG" >&2
           echo "$usage" >&2
           exit 1
           ;;
      esac
    done
    shift $((OPTIND - 1))

    if [ -z $filter ] ; then
        filter=$(git symbolic-ref -q HEAD)
    fi

    current_branch=`git_get_branch_name`

    git for-each-ref --format="%(refname:short) %(upstream:short)" $filter | \
    while read local remote
    do
        if [ -n "$compareto" ] ; then
            remote="$compareto"
        fi
        #[ -z "$remote" ] && continue
        if [ -z "$remote" ]
        then
            # If no upstream has been set, we could guess a remote branch with the same name
            remote="origin/$local"
            if ! gb --list -r "$remote" | grep . >/dev/null
            then continue
            fi
        fi
        DELTAS=$(git rev-list --left-right ${local}...${remote})
        LEFT_AHEAD=$(echo "$DELTAS" | grep -c '^<')
        RIGHT_AHEAD=$(echo "$DELTAS" | grep -c '^>')
        if [ "$local" = "$current_branch" ]
        then preBranch="* "
        else preBranch=". "
        fi
        if [ $verbose ] || [ $LEFT_AHEAD -gt 0 ] || [ $RIGHT_AHEAD -gt 0 ] || [ "$local" = "$current_branch" ] ; then
            #echo "$local $WARN_LEFT(ahead $LEFT_AHEAD)$reset_color | $WARN_RIGHT(behind $RIGHT_AHEAD)$reset_color $remote"
            echo "$preBranch$local (ahead $LEFT_AHEAD) | (behind $RIGHT_AHEAD) $remote"
        fi
    done
}
gbs() {
  # A wrapper for git_branch_status that adds color.
  # Displays status of current branch relative to upstream and downstream versions
  # With no arguments, inspects all branches
  # With argument `.`, displays current branch
  # With any other argument, uses that as the branch name
  # If the branch has no upstream (pull) specified, then assume origin/<branch_name> if it exists, otherwise assume origin/master
  # If the branch has no downstream (push) specified, then assume origin/<branch_name>
  # This may help: http://stackoverflow.com/questions/2969214/git-programmatically-know-by-how-much-the-branch-is-ahead-behind-a-remote-branc
  # git branch -v can partially do this already.  It shows e.g. [behind 12] after the commit hash but before the message.  Unfortunately it has no color and does not stand out very well.
  # Or perhaps better: https://gist.github.com/jehiah/1288596 (from http://stackoverflow.com/questions/7773939/show-git-ahead-and-behind-info-for-all-branches-including-remotes )

  local reset_color=`tput sgr0`
  local ahead_color=`tput setaf 2 ; tput bold`
  local behind_color=`tput setaf 1 ; tput bold`
  # You can use the configured/default colors, but I quite like remote blank!  (The default red confuses behind_color.)
  local current_branch_color=`git config --get-color color.branch.current green`
  # I don't think anyone really wants color.  If you do, uncomment these:
  #local local_branch_color=`git config --get-color color.branch.local white`
  #local remote_branch_color=`git config --get-color color.branch.remote red`

  if [ "$1" = . ]
  then shift ; git_branch_status "$@"
  else git_branch_status -a "$@"
  fi |
  column -s ' ' -t | sed 's+ \( *\)+\1+g' |
  #columnise |
  #highlight -bold "(ahead *[1-9][0-9]*)" green |
  #highlight -bold "(behind *[1-9][0-9]*)" red |
  sed "
    s+(ahead *[1-9][0-9]*)+$ahead_color\0$reset_color+
    s+(behind *[1-9][0-9]*)+$behind_color\0$reset_color+
    s+^[*] *\([^ ]*\)+* $current_branch_color\1$reset_color+
    s+^[.] *\([^ ]*\)+  $local_branch_color\1$reset_color+
    s+[^ ]*$+$remote_branch_color\0$reset_color+
  "
}

git_get_branch_name() {
	git rev-parse --abbrev-ref HEAD
}

git_find_branch_start_commit() {
	local other_branch current_branch

	# It is more likely we want to compare the current branch against an alternative, than to compare an alternative against master.  So we accept the alternative first.
	if [ -n "$1" ]
	then other_branch="$1"
	else
		#other_branch=master
		#other_branch=origin/master
		#other_branch=v3-alpha-stable
		other_branch=v3-master
	fi

	# But user may specify the "current" branch second if they wish
	if [ -n "$2" ]
	then current_branch="$2"
	else current_branch=`git_get_branch_name`
	fi
	# Although the order doesn't really matter when passing 2 arguments, since merge-base is symmetric!

	# This is not guaranteed, but the information is likely still in the cache if the branch was created in the last 90 days.
	# In fact it completely fails if you have pulled the branch from a remote repository.  It shows the HEAD at the time that you pulled!
	#git reflog show $current_branch | tail -n 1

	git merge-base "$other_branch" "$current_branch"
}

git_find_branch_start() {
	local commitId=`git_find_branch_start_commit`

	if [ -n "$commitId" ]
	then
		echo "$current_branch and $other_branch share common commit:"
		#git log --pretty=oneline -1 "$commitId"
		glc -1 "$commitId"
	fi
}

