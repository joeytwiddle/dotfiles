# What is useful in this file?
#
# Shortcuts:
#
#   gs ga gd gc gb gco and gm are simple aliases for git status, add, diff,
#   commit, branch, checkout and merge.  Use them to save yourself keystrokes.
#
#   gll shows a log *overview*, with one commit per line, with graph layout.
#
#   gl is my favourite *detailed* log display, showing diffs, stats and commit
#      messages and graph.  Keys n and N jump forwards/backwards through diffs.
#
#   gmo does git merge origin/<current_branch>
#
#   gpo does git push origin <current_branch>
#
# Powerful tools:
#
#   gbs [-M] [.] is "git branch status", a nice way to see which branches are
#       up-to-date with the remote (which need a push and which need a pull).
#
#       Use `gbs .` to show the status of the current branch only (faster).
#
#   gbd [-M] [-r] [-n <num>] is "git branch by date", a nice way to see which
#       branches were recently updated.  -r lists remote branches.
#
#   The -M argument to gbs and gbd is slower, but will display whether or not
#   each branch has been merged into the current branch.  Cool!
#
#   gbd will only align neatly into columns if you have jsh's columnise-clever
#   installed.  Making that work independently is something I should TODO!
#
# Some more shortcuts:
#
#   gap and gcp let you select which chunks of code to stage or commit next
#
#   gdc shows the "cached" diff of what is staged (what you are about to commit).
#
#   gdv and glv open diffs and logs in Vim, folded, for interactive browsing.
#
#   gwinp "git what is not pushed" lists commits on local branch not yet pushed
#   gwinm "git what is not merged" lists new commits from remote not yet merged
#
# I hope these shortcuts and tools will be of use to you.
#
# I rarely use the other aliases and functions in this file (except of course
# indirectly those which are dependencies of the ones I do use!).
#
# Some of the functions (gbs, gbd) do not work on Mac OSX / FreeBSD because I
# don't know how to get BSD sed to do search-replace.  However if you have
# installed the GNU coreutils package (e.g. via Homebrew) and GNU sed is on
# the *front* of your path, then they should work fine.

# If you think this file has too many comments in it, try: :hi Comment guifg=#222222

# CONSIDER: Turn the aliases into shellscripts so they are available from vim's command line?
#       Put them somewhere and load them onto the PATH optionally.  (Not everyone will want them.)  jsh modules...

# If you happen to be using oh-my-zsh's git plugin, redefining its aliases will throw warnings, so we undefine them first.
unalias gs 2>/dev/null
unalias gd 2>/dev/null
unalias gitlog 2>/dev/null
unalias gac 2>/dev/null
unalias gitwhatsup 2>/dev/null
# By the way, if you want to undefine a function instead of an alias, this works for bash and zsh:
#   unset -f fn_name

#alias gs='git status'
gs() {
	# Show color if not piping.  Skip to next section on 'n'.  Leave output on screen with -X (so user can copy paste).
	# Using more instead of less because on short output, less fills the rest of the screen with '~'s (or ''s) we don't need.  Those lines are actually caused by the search.  git's default 'pager' will do the same iff the +/ is added.
	# More has slightly different searching behaviour than less: it will not skip to the start of a section which is already visible on the screen.
	# This now rather equivalent to the default, except for the default search.
	if [ -t 1 ]
	then
		git -c color.status=always status "$@" |
		#more
		# On Mac, more cannot handle color.  Unless it is given -R.  But Linux more does not recognise that argument!  :P
		# I think the disadvantage with less might be when the output is lesser than the screen height, then more will just display those few lines and quit, but less will occupy the entire screen.  Also, does less destroy scrollback, while more preserves it?
		less -R -E -X
		# But can we use the more-like options for less below on Mac?
                # Hmmm that's not quite as neat: on short output, the bottom part of the screen is filled with empty lines.
		# The problem with doing this search with more is that more skips the first "branch" line, even though it is a match.  And it does not even allow paging up to find it!
		#more +'/^# [^ ].*'
		#less -R +'/^# [^ ].*' -E -X --tilde
		#pager -R +'/^# [^ ].*' -E -X --tilde
	else git status "$@"
	fi
}

#alias gd='git diff'
gd() {
	# Show color if not piping.  Skip to next file on 'n'.
	if [ -t 1 ]
	then git -c color.diff=always diff "$@" | less -R +'/^diff.*' -X
	else git diff "$@"
	fi
}
# Git Diff Words
alias gdw='git diff --word-diff=color'
# Git Diff Files
alias gdf='git diff --stat'
# Git Diff Staged / Cached (see which one I use most ... I used gdc!)
#alias gds='gdc'
alias gdc='gd --cached'

alias ga='git add -v'
# I often like to do git commit -a, and wonder why there is no equivalent git add -a.  In fact there is, but the flag is -u!
alias gau='ga -u'
alias gaa='gau'
#alias gc='git commit'
alias gc='git commit -v'
alias gca='gc --amend'
alias gcm='gc -m'
# I think I tend to use --amend more than -a.  At least, I like to be explicit about -a.  (But probably feel the same about --amend)
# gcam providing --amend
alias gcam='gc --amend -m'
# gcam providing -a
#alias gcam='gc -a -m'
alias gci='git commit --interactive'
# -p "patch" allows us to choose which hunks to add or commit
alias gap='ga -p'
alias gcp='gc -p'

alias gf='git fetch -v'
alias gp='git pull'
alias gpr='git pull --rebase'
alias gpp='git pull --rebase && git push'

#alias gm='git merge'
# Git Merge Origin (this branch)
#alias gmo='verbosely git merge $(git_guess_upstream_branch)'
alias gmo='verbosely git merge origin/$(git_get_current_branch)'
# Git Push Origin (this branch)
alias gpo='verbosely git push origin $(git_get_current_branch)'
alias gmm='verbosely git merge master'
alias gmom='verbosely git merge origin/master'

alias gr='git reset'
alias grh='gr --hard'

alias gri='git rebase -i'

#alias gp='git preview'   # This was defined in my .gitconfig as: git diff --stat HEAD..FETCH_HEAD
#alias gw='git whatsnew'

#alias gl='git log'
#alias gl='git log -U2 -p -m'
# I thought it might be nice to setup less so that we can jump to the next commit with 'n'
# Unfortunately whilst this provides the feature, git disables colors:
#   gl | less +"/^commit.*" -r
# Oh, fixed it.  Since this make paging commits very fast, now adding --stat
#alias gl='git -c color.ui=always log -U2 -p -m --stat | less -R "+/^commit.*"'
gitlog() {
	# Show color if not piping.  Skip to next file or commit on 'n'.
	if [ -t 1 ]
	then
		git -c color.ui=always log "$@" |
		#less -R +'/^(commit|diff).*' -X
		# Needed when using --graph and -p
		less -R +'/((^|\*[ |]*)commit .*|(^|\| +)diff --(git|combined).*)'
	else git log "$@"
	fi
	# BUG TODO: The --git may show as --combined when using gl -c, so change it for just -- after the pending merge.
}
# The regexp search allows us to quickly skip to the next diff or commit header by pressing `n`.  If you do not wish to jump through the diffs, you have two options:
#   1. Edit the search so it won't hit diff lines.  For example: `/<Left><Left><Left>z<Enter>`.  This will work for the rest of the session.
#   2. Count the number of files in this commit (as shown by --stat), add one, and jump that many times with e.g. `15n`.  This will work just once, so you can use `n` to skip diffs later.

# "Git Log Pure" - the basis for "Git Log Grey" but without colours
# I am not sure how useful -m is.  It shows us the diff of the merge *and* the individual commits from the merged branch, so we see some things twice.  We may want to remove it, or add --no-merges and/or --first-parent, so we can see the individual commits from merged branches, without the merge commits themselves (which would be duplicate information!).  The disadvantage is that by hiding merges, we don't see the correct moment at which the commit entered our local branch.  Perhaps we want to view the merges but not the commits from merged branches!  That is exactly the behaviour of --first-parent; then we should keep -m.  But then we can't see the log messages for those commits.
# So some sensible choices are: -m --first-parent to see the changes at merge time, or neither to see the log messages of individual commits.
# Probably the second is more desirable for gll, the first more desirable for glf or gld (gl).  Especially the first is useful because it shows us the fixed conflict files during a merge.  (So we can check that a merge has not snuck in unwanted code during the conflict resolution.)
# We could also try out --cc or -c options.
# Nah they didn't see helpful.  It's either -m --first-parent or neither.
# I think I originally added -m because I *thought* git log was not showing commit diffs from merged branches.  In fact it does, but it shows them individually, and leaves the merge commit itself empty.
# I am now finding this a little more informative than glg: git log -p --graph --decorate
# I rarely want to use glp directly; I prefer glg because it customizes the color of the commit message.
# OK so I recently had to track down some code which had been deleted/lost during a merge.  I was using git log <filename>.  The *only* way which worked was -c; -cc or neither would not display this line!  So -c all the way... at least for that case!  If -c causes duplicate information to be displayed, perhaps we should use it at the same time as not showing branches.
alias glp='gitlog -p -U2 --stat'
# Here --stat show a quick summary of changed files, before actually showing the diffs.  I rather enjoy this when using 'gl' as it lets me decide from the top of each commit whether there are any files I am interested in, and if not I can happily skip straight to the next commit.  In other situations, e.g. when I am planning to read all the details, --stat is just chaff.
# "Git Log Grey" - Like 'gl' except we present my favourite colors
# This is quite close to: git log --decorate -U2 -p -m --stat
# Curiously the alias shows fewer +++s and ---s on the stat output.
# One "advantage" of our custom format over --decorate is that --decorate shows different colors for different decorations.  Whilst this is nice and informative, it looks a little ugly when it combines with the reverse highlighting from our less search.
alias glg='glp --format=format:"%C(yellow bold)commit %H%C(magenta bold)%d%C(reset)%nAuthor: %an <%ae>%nDate:   %ad%n%n    %C(black bold)%s %C(reset)%C(yellow)%Creset%n"'
# Custom_format_bugs: Note that %b is missing (it should come after %s%n, it may show 'Conflicts' list or other useful notes).  But adding it conditionally is a hassle.
# "Git Log" aliases to "Git Log Grey"
#alias gl='glg'
# Now trying this out; use glm for old-ish style (merges merged) or use glg to see individual commits without the graph.
# We should probably swap glg and gl, since gl has a graph and glg does not!
# Interestingly this can show some commits in a different order from glg alone, in the presence of merges.
alias gl='glg --graph'
# glx is like gl but without my custom format colours and without my Custom_format_bugs.
alias glx='glp --graph'
# Warning: glg and glc duplicate my color settings.  (Which are also set in my ~/.gitconfig.)  Part of the reason I passed everything through glg/glc was to display decorations (commit labels like HEAD and origin/master).  I have since learned this can be achieved by passing --decorate, so we may be able to reduce some duplication that way.
# "Git Log with Merges-combined/merged)" - shows diffs in the merge, does not show individual commits from merged branches
alias glm='glg -m --first-parent'
# It seems to me that -c should be combined with --first-parent, to avoid seeing the same diffs twice (the final actual merge, as well as the commits on the branch)
# When -c is used, -m does nothing (at least in the example I tested)
# I did tests comparing `glg -c` against `glg -m`, and `glg -c --first-parent` against `glg -m --first-parent`.  Whilst -c did show the full diff of manual merges, it also excluded a lot of stuff!  Notably, merges with no conflicts.  (From the manual: "it lists only files which were modified from all parents").  So I don't see any way to see the true patched of manual merges (-c) without also excluding stuff.  Therefore, use -c only when you think you need it!  :P

# "Git Log Clear" - Single lines, no graph.  Shows more info than: git log --pretty=oneline
# If you want to use this with --stat and --graph then it should have a %n at the end.  But this will make --graph show blank lines even when run without --stat.  Since glf does not use --graph, we don't really need this.
alias glc='git log --pretty=format:"%C(yellow bold)%h%C(magenta bold)%d%C(reset) %C(black bold)%s %C(reset)%C(cyan)- %an (%ar)%Creset"'

# "Git Log Long" - One per line, with graph
#alias gll='git log --graph --decorate --pretty=oneline --abbrev-commit --all'   # Does not show committer's name or age of commit
#alias gll='git lol'
# Using the same colors as "Git Log Clear" except commits are not bold:
#alias gll='git log --graph --pretty=format:"%C(yellow)%h%C(magenta bold)%d%C(reset) %C(black bold)%s %C(reset)%C(cyan)- %an (%ar)%Creset"'
# Problem: When used with --graph, glc should end in %n.  But we don't want the %n when --graph is not used (e.g. in glf below)!  I don't personally want the %n, but --graph always draws a |\n straight after the formatted text, so it looks messy without it.
alias gll='glc --graph'
# "Git Log Long Minus merges"
# This lists the merge commits themselves, but does not list any of the commits that were brought in by the merge.  This is useful if you have merged things into the current branch, but you are only interested in the commits that were actually made on the current branch.
# When using this, it can be nice to clearly distinguish merges from raw commits.  If your merge commit messages are pure, you can search /Merge.* or cleaner /Merge.* into [^ ]*
# gllm | highlight -bold -reverse "Merge.* into [^ ]*" magenta | more
if which highlight >/dev/null
then
	# Better because it allows arguments to be passed.  Breaks if glc is not aliased until later.
	gllm() {
		gll -m --first-parent "$@" |highlight -bold "Merge.*" blue | less -REX
	}
	#alias gllm='gll -m --first-parent | highlight -bold "Merge.*" blue | less -REX'
else alias gllm='gll -m --first-parent'
fi
# This shows the commits from merged branches (/), but not the merge commits themselves (\).  It takes less space than gll.
alias gllnm='gll --no-merges'
# Git Log Long No Graph
alias gllng='glc'
alias glls='gll --stat'

# "Git Log Word-diffed" - It is debatable whether we want to page through diffs or just whole commits; it kinda depends what the user is looking for that particular time!
alias glw='gl --word-diff=color'
# "Git Log Stats/Summary" - Just file stats, no diffs.  BUG: Not grey, because glg uses glp which does -p (diffs)!
alias gls='gitlog --stat'
# "Git Log Files" - Compressed version of "Git Log Stats"
#alias glf='glc --stat'
# New version allows easy n/N searching.  Could be merged with gitlog.
gitlog2() {
	if [ "$1" = "-search" ]
	then search="$2"; shift; shift
	else search='^$'
	fi
	glc "$@" | less -R +"/$search"
}
alias glf='gitlog2 -search "^[^ ]+" --stat'
# With glf, we can walk commmits with /^[^ ]+
# Just commit info, one per line

alias gb='git branch'

# Git View Branches (tree-like)
alias gvb='git log --oneline --decorate --graph --simplify-by-decoration'
# For remotes too, add: --all
# Could also be Git View Tree or Git Tree View, although I might want to save those for gitv!  :P

unalias gco 2>/dev/null   # REMOVEME
#alias gco='git checkout'
gco() {
	git checkout "$@"
	local ret_status="$?"
	if [ "$ret_status" = 0 ] && [ -n "$POST_GIT_CHECKOUT" ]
	then "$POST_GIT_CHECKOUT" "$@"
	fi
	return "$ret_status"
}
POST_GIT_CHECKOUT=update_cindex
if ! which ionice >/dev/null
then
	ionice() {
		"$@"
	}
fi
update_cindex() {
	if which cindex >/dev/null && ( [ -z "$CSEARCHINDEX" ] && [ -f "$HOME"/.csearchindex ] || [ -n "$CSEARCHINDEX" ] && [ -f "$CSEARCHINDEX" ] )
	then
		local git_root_folder=$(git rev-parse --show-toplevel)
		# If any of the indexed folders are equal to or below this project's folder
		if [ -n "$git_root_folder" ] && cindex -list | grep -q "^$git_root_folder\($\|/\)"
		then
			echo -n "Updating cindex (in the background)"
			nice ionice cindex 2>/dev/null &
		fi
	fi
}

# TODO: There are a number of other occasions when cindex should be run, e.g. after a pull, reset or file save!  Perhaps it would be better if any programs which use csearch should just run cindex every time before they run csearch.  That should still be faster than grep!

# Git What Is Not Pushed (doesn't always work - I use gbs more often)
#alias gwinp='gll @{upstream}..HEAD'
alias gwinp='gll $(git_guess_upstream_branch)..HEAD'
# Git What Is Not Pushed Log
alias gwinpl='gl $(git_guess_upstream_branch)..HEAD'
# Git What Is Not Pushed Files
alias gwinpf='glf $(git_guess_upstream_branch)..HEAD'
# Git What Is Not Pushed Diff
alias gwinpd='gd $(git_guess_upstream_branch)..HEAD'

# Shortcuts I never used
## Git To Push
#alias gtp='gwinp'
## Git To Push Log
#alias gtpl='gwinpd'
## Git To Push Files (often works poorly since it compares against FETCH_HEAD)
#alias gtpf='git topush'
## Git To Push Details / Diff (a direct diff, without listing each commit)
#alias gtpd='gwinpd'

# Git What Is Not Merged
alias gwinm='gll HEAD..$(git_guess_upstream_branch)'
# Git What Is Not Merged Log
alias gwinml='gl HEAD..$(git_guess_upstream_branch)'
# Git What Is Not Merged Files
alias gwinmf='glf HEAD..$(git_guess_upstream_branch)'
# Git What Is Not Merged Diff
alias gwinmd='gd HEAD..$(git_guess_upstream_branch)'

alias gss='git stash save'
#alias gsp='git stash pop'
alias gsp='git_stash_pop_safe'
alias gsa='git stash apply'
alias gsl='git stash list'
# Git Stash Diff shows the diff of the topmost or specified stash.  Notably not `git stash drop` which must be typed in full, to avoid doing it too easily and accidentally.
alias gsd='git stash show -p'
# Git Stash (diff) Files shows the files changed (like --stat)
alias gsf='git stash show'
# TODO: I would actually like an easy way to display the diffs for all the stashes, i.e. run gsd for every stash id

grho() {
	local current_branch=`git_get_current_branch`
	verbosely git reset --hard "origin/$current_branch"
}

# Sometimes popping the state results in conflicts because I was popping onto the wrong branch.  I can reset to restore the files, but then I will have lost my stashed changes, because they were popped!
# So git_stash_pop_safe will only drop the stash if it was successfully applied with no conflicts.
git_stash_pop_safe() {
	git stash apply "$@" && git stash drop "$@"
}

# Git Auto Commit, or Git Add Commit, or Git Add and Commit
gac() {
	git add "$@"
	echo -n "Commit message: "
	read msg
	git commit -m "$msg"
}

if ! which verbosely >/dev/null
then
	verbosely() {
		echo "[EXEC] % $*" >&2
		"$@"
	}
fi

# Git Branch by Date
git_branch_by_date() {
	local reset_color=`tput sgr0 | sed 's/$//'`
	# Optional
	local subject_color=`tput setaf 0 ; tput bold`
	local author_color=`tput setaf 6`

	local target=refs/heads
	#local commit_color=`git config --get-color color.diff.commit yellow`
	if [ "$1" = -r ]
	then
		#target=refs/remotes/origin
		target=refs/remotes
		#branch_color=`git config --get-color color.branch.remote red`
	fi

	# %(committerdate:iso8601)
	git for-each-ref --sort=committerdate $target --format="%(refname:short) ${author_color}%(committerdate:relative) (%(authorname)) -${reset_color} ${subject_color}%(subject)${reset_color}"
}

# Git Branch by Date wrapper
gbd() {
	# In tmux, reset_color gets an extra `^O` on the end, which the terminal ignores, but which will show up if output is piped to less.  It happens when TERM=screen or screen-256color, but it goes away if we set TERM=xterm.  For now we will just strip that trailing `^O` char.
	local reset_color=`tput sgr0 | sed 's/$//'`
	local current_branch_color=`git config --get-color color.branch.current green`
	local branch_color=`git config --get-color color.branch.local white`

	# TODO: Parse args in no particular order, and show help, like gbs does
	# CONSIDER: Decide whether or not to show_color based on terminal type, and arguments

	# For quick results, we show just one page of history by default
	local count=$((LINES-2))
	# but if the user is piping (e.g. to grep), then we should search further back (but not too far because a lot of branches can make -M very slow)
	if [ ! -t 1 ]
	then count=500
	fi
	local showancestors=''
	if [ "$1" = "-M" ]
	then showancestors="yes" ; shift
	fi
	if [ "$1" = "-n" ]
	then count="$2"; shift; shift
	fi

	local need_pager=
	if [ $count -gt $((LINES-2)) ]
	then need_pager=1
	fi

	current_branch=`git_get_current_branch`

	git_branch_by_date "$@" |
	tail -n "${count}" |
	while read refname rest
	do

        local local="${refname}"
        ## NOTE: This code is cloned from gbs.  Can we refactor it out?
        if [ "$local" = "$current_branch" ]
        then preBranch="* "
        else
            preBranch=". "
            if [ -n "$showancestors" ]
            then
                local_branch_commit_hash=`git rev-parse --verify "$local"`
                common_commit_between_branch_and_current=`git merge-base "$local" "$current_branch"`
                if [ "$common_commit_between_branch_and_current" = "$local_branch_commit_hash" ]
                then preBranch="| "
                else preBranch="/ "
                fi
                # I considered using "+" and "-" instead, but these are harder to visually distinguish from "*" and each other.
                # Another alternative I tried was "~" and "x", but again the "*" is easily lost there.
            fi
        fi

		echo "${preBranch}${refname} ${rest}"
	done |

	if which columnise-clever >/dev/null
	then columnise-clever -ignore '[^ ]* *[^ ]* *[^ ]*'
	else cat
	fi |
	replace_ancestor_markers_with_colors |
	if [ -n "$need_pager" ]
	then
		# -R=show_colors -X=no_clear -S=chop_long_lines +G=jump_to_end
		less -R -X -S +G
		#more -R   # (since more=less on Mac; fails on Linux)
	else
		# -E=quit_at_end (in other words this just chops long lines)
		less -R -E -X -S +G
		#cat
	fi
}

# May rename "gitsummary"
gitwhatsup() {
	echo
	# Absolute path:
	local gitDir=$(git rev-parse --show-toplevel)/.git
	# On some systems, gives relative path:
	#local gitDir=$(git rev-parse --git-dir)
	local greenBackground=$(tput setab 2)
	local whiteForeground=$(tput setaf 7)
	#echo "${greenBackground}${whiteForeground}$(cursebold)GITDIR:$(tput init) $gitDir"
	echo "`cursecyan`=== Git directory ===`cursenorm`"
	echo "$gitDir"
	echo
	#echo "`cursecyan`$gitDir`cursenorm`"
	#echo "${greenBackground}${whiteForeground}$(cursebold)$gitDir$(tput init)"
	echo "`cursecyan`=== Remotes ===`cursenorm`"
	git remote -v #| prepend_each_line "   "
	echo
	echo "`cursecyan`=== Local branches ===`cursenorm`"
	git branch -vv #| prepend_each_line "   "
	echo
	echo "`cursecyan`=== Remote branches ===`cursenorm`"
	git branch -r -vv #| prepend_each_line "   "
	echo
	echo "`cursecyan`=== Not yet pushed ===`cursenorm`"
	gll "@{u}..HEAD" | cat
	echo
	echo
	# Try `git remote update` if you can't see all the remote branches
}
alias gwu=gitwhatsup

# Guesses the name of the upstream branch, given the local branch name (or no arguments, which assumes current branch)
git_guess_upstream_branch() {
	local local_branch remote_branch remote_commit
	# No problem if this arg is empty, it will work fine for the current branch anyway
	local_branch="$1"
	# First guess
	remote_branch="$local_branch@{upstream}"
	# Check if it exists
	# We cannot use --symbolic or --abbrev-ref here; it will return what was given even if no upstream exists.
	# In fact we must specify --revs-only to prevent that from occurring!
	# We hide the error if the remote branch is not found.
	# BUG: On git 1.8.5.2 on MacOSX, we are getting remote_commit='a_long_hash_id'  I was hoping it would be empty, so we could at least guess a symbolic remote branch.
	remote_commit=$(git rev-parse --revs-only "$remote_branch" 2>/dev/null)
	if [ -z "$remote_commit" ]
	then
		# If no upstream was set, guess a branch on "origin" with the same name.  TODO: if "origin" does not exist, can we make a better guess?
		# Before we can do that, we may need a name for the local branch, if none was provided
		if [ -z "$local_branch" ]
		then local_branch=$(git_get_current_branch)
		fi
		remote_branch="origin/$local_branch"
		# Check if it exists (we could have probably done this the same way we used earlier)
		if ! git branch --list -r "$remote_branch" | grep . >/dev/null
		then remote_branch=""
		fi
	fi
	echo "$remote_branch"
}

vim_for_git_logs() {
	# Our mappings use z<CR> to scroll so the cursor is at the top of the window after n/N search
	# I tried setting scrolljump=-99 and got a screen jump when going of the bottom, but only half when going off the top.
	local vim_exe=vim
	#local vim_exe=gvim
	"$vim_exe" +'setlocal nomodified nomodifiable filetype=git foldmethod=syntax foldcolumn=2' \
	    +'/^\(commit\|diff --git\|diff --combined\) .*' \
	    +'normal gg' \
	    +'highlight clear Search' \
	    +'"When seeking, scroll destination line to top of screen' \
	    +'set scrolloff=0' \
	    +'nnoremap n nzt' \
	    +'nnoremap N Nzt' \
	    +'"But when the user performs a custom search, undo the above mappings' \
	    +'nnoremap / :nunmap n<CR>:nunmap N<CR>:nunmap /<CR>/' \
	    "$@"
	    #+'set nohlsearch' \
}

vim_for_git_logs_from_stdin() {
	#cat > /tmp/vim_for_git_logs.out
	#vim_for_git_logs "$@" /tmp/vim_for_git_logs.out
	vim_for_git_logs "$@" -
}

# Git Log in Vim
glv() {
	local count=50
	if [ "$1" = -n ]
	then
		count="$2"
		shift
		shift
	fi
	git log -p -n "$count" "$@" | vim_for_git_logs_from_stdin
}

# Git Diff in Vim
gdv() {
	git diff | vim_for_git_logs_from_stdin
}

# To delete local branches which have been merged into master:
#   git branch --merged master | grep -v "\* master" | xargs -n 1 git branch -d

git_branch_status() {
    # Original: https://gist.github.com/Mark-Booth/5058384
    # This version by Joeytwiddle

    # Displays your git branches with a summary of how many commits ahead or behind the local is from its remote branch.
    # Also displays (through color/labels) which branches are ancestors of (have already been merged into) the current branch.

    # If no upstream is set for a branch, it will guess a branch with the same name on origin.
    # Use the 'gbs' alias wrapper below for colors and column alignment.

    # example:
    # $ git branch-status -a
    # dns_check (ahead 1) | (behind 112) origin/master
    # master (ahead 2) | (behind 0) origin/master
    # $ git branch-status
    # master (ahead 2) | (behind 0) origin/master

    # Surely this was a non-local variable leaking out of git_branch_status and has already been fixed.
    # BUG (fixed?): Running gbs after git_branch_status -a -v gives only 1-line output.  Steps to reproduce:
    # Use Mac.  Start jsh in bash (with GNU coreutils etc.).  See gbs works fine.  Now do git_branch_status -a -v, also works fine.
    # Now see gbs only displays one line!
    # From initial tracing, it appeared that the final gbs call only iterates once during the while getopts.
    # Since we need both -v and -a to show more than one line here, we saw only one line.

    local usage option filter OPTARG compareto showancestors verbose branch_name_regexp

    local current_branch local remote DELTAS LEFT_AHEAD RIGHT_AHEAD preBranch
    local local_branch_commit_hash common_commit_between_branch_and_current abstatus

    local sorting=

    usage="$(basename "$0") [-hamtMv] [<branch_name_regexp>] -- summarise status of branch(es)

where:
    -h           show this help text
    -a           show all branches, not just the current one
    -m           shows branch(es) with respect to origin/master
    -t <branch>  shows branch(es) with respect to given branch
    -d           sort by date (default is to sort by name)
    -M           indicates branches which have been merged into current
    -v           verbose, show output even if counts are zero"

    while getopts 'hamt:pdMv' option; do
      case "$option" in
        h) echo "$usage"
           return # exit
           ;;
        a) filter=refs/heads
           ;;
        m) compareto=origin/master
           ;;
        t) compareto="$OPTARG"
           ;;
        d) sorting="--sort=committerdate"
           ;;
        M) showancestors=true
           ;;
        v) verbose=true
           ;;
        ?) printf "illegal option: '%s'\n" "$OPTARG" >&2
           echo "$usage" >&2
           return # exit 1
           ;;
      esac
    done
    shift $((OPTIND - 1))

    branch_name_regexp="$1"
    if [ -n "$branch_name_regexp" ]
    then filter=refs/heads
    fi

    if [ -z $filter ] ; then
        filter=$(git symbolic-ref -q HEAD)
    fi

    current_branch=`git_get_current_branch`

    git for-each-ref $sorting --format="%(refname:short) %(upstream:short)" $filter |
    grep -e "$branch_name_regexp" |
    while read local remote
    do
        if [ -n "$compareto" ] ; then
            remote="$compareto"
        fi
        #[ -z "$remote" ] && continue
        # This is an assumption I made for our project - that if a branch does not have an upstream set, then we should assume the upstream is a branch on 'origin' with the same name.
        # It could be avoided if we used --track when initially creating the local branch with git branch or git checkout.  Tracking can also be setup retrospectively with `git branch -u <remote_branch>` in Git > 1.8.0 or `git branch --set-upstream <local_branch> <remote_branch>` in Git > 1.7.0.
        if [ -z "$remote" ]
        then
            # If no upstream has been set, assume a remote branch with the same name
            remote="origin/$local"
            if ! git branch --list -r "$remote" | grep . >/dev/null
            then
                # No remote branch exists
                remote=""
                # But if this is the current branch, or we are in verbose mode, we might still like to display it anyway.
                # However ahead/behind counts are meaningless without a remote.
                if [ "$local" = "$current_branch" ] || [ -n "$verbose" ]
                then :
                else continue
                fi
            fi
        fi
        # If we do not have a remote to compare to, display no counts, rather than relative to current branch, which is quite arbitrary (but can be achieved using $compareto if desired).
        if [ -n "$remote" ]
        then DELTAS=$(git rev-list --left-right ${local}...${remote})
        else DELTAS=""
        fi
        LEFT_AHEAD=$(echo "$DELTAS" | grep -c '^<')
        RIGHT_AHEAD=$(echo "$DELTAS" | grep -c '^>')

        if [ "$local" = "$current_branch" ]
        then preBranch="* "
        else
            preBranch=". "
            if [ -n "$showancestors" ]
            then
                # We can actually get a list of merged branches from: git branch --merged $current_branch
                # http://devblog.springest.com/a-script-to-remove-old-git-branches/
                local_branch_commit_hash=`git rev-parse --verify "$local"`
                common_commit_between_branch_and_current=`git merge-base "$local" "$current_branch"`
                if [ "$common_commit_between_branch_and_current" = "$local_branch_commit_hash" ]
                then preBranch="| "
                else preBranch="/ "
                fi
                # I considered using "+" and "-" instead, but these are harder to visually distinguish from "*" and each other.
                # Another alternative I tried was "~" and "x", but again the "*" is easily lost there.
            fi
        fi

        if [ $verbose ] || [ $LEFT_AHEAD -gt 0 ] || [ $RIGHT_AHEAD -gt 0 ] || [ "$local" = "$current_branch" ] ; then
            if [ -z "$remote" ]
            then abstatus="(none)"
            else abstatus="(ahead $LEFT_AHEAD) | (behind $RIGHT_AHEAD)"
            fi
            echo "$preBranch$local $if_merged$abstatus $remote"
        fi
    done
}
gbs() {
  # A wrapper for git_branch_status that adds color.
  # Displays status of current branch relative to upstream and downstream versions
  # With no arguments, inspects all branches
  # With argument `.`, displays current branch
  # With any other argument, uses that as the branch name
  # If the branch has no upstream (pull) specified, then assume origin/<branch_name> if it exists, otherwise assume origin/master
  # If the branch has no downstream (push) specified, then assume origin/<branch_name>
  # This may help: http://stackoverflow.com/questions/2969214/git-programmatically-know-by-how-much-the-branch-is-ahead-behind-a-remote-branc
  # git branch -v can partially do this already.  It shows e.g. [behind 12] after the commit hash but before the message.  Unfortunately it has no color and does not stand out very well.
  # Or perhaps better: https://gist.github.com/jehiah/1288596 (from http://stackoverflow.com/questions/7773939/show-git-ahead-and-behind-info-for-all-branches-including-remotes )

  local show_color
  local color_setting=`git config --get color.ui`
  if [ "$color_setting" = 'true' ] || [ "$color_setting" = 'auto' ] && [ -t 1 ]
  then show_color=true
  fi

  if [ "$1" = . ]
  then shift ; git_branch_status "$@"
  else git_branch_status -a -v "$@"
  fi |
  column -s ' ' -t | sed 's+ \( *\)+\1+g' |
  #columnise |
  if [ -n "$show_color" ]
  then
    # We should probably only do this jazz if $() = 'true' or = 'auto' && [ -t 1 ]
    local reset_color=`tput sgr0`
    local ahead_color=`tput setaf 2 ; tput bold`    # green
    local behind_color=`tput setaf 1 ; tput bold`   # red
    # Git's default remote branch color is red, but that conflicts with behind_color, so I have set it to 'white' here.
    local remote_branch_color=`git config --get-color color.branch.remote white`
    sed "
      s+\()  *\)\([^ ]*\)$+\1$remote_branch_color\2$reset_color+
      s+(ahead *[1-9][0-9]*)+$ahead_color\0$reset_color+
      s+(behind *[1-9][0-9]*)+$behind_color\0$reset_color+
    " |
    replace_ancestor_markers_with_colors
  else cat
  fi
}

replace_ancestor_markers_with_colors() {
	local current_branch_color=`git config --get-color color.branch.current green`
	local local_branch_color=`git config --get-color color.branch.local white`
	local ancestor_branch_color=`git config --get-color color.branch.ancestor cyan`
	sed "
		s+^[*] *\([^ ]*\)+* $current_branch_color\1$reset_color+
		s+^[./x-] *\([^ ]*\)+  $local_branch_color\1$reset_color+
		s+^[\\+|] *\([^ ]*\)+  $ancestor_branch_color\1$reset_color+
	"
}

git_get_current_branch() {
	# symbolic-ref fails during an incomplete rebase with `fatal: ref HEAD is not a symbolic ref`
	# It can also fail on git 1.7 with "unknown option `short`"
	#git symbolic-ref --short HEAD
	# rev-parse does not fail, but responds with "HEAD" instead of the branch name.
	#git rev-parse --abbrev-ref HEAD
	# So for git 1.7 we do:
	local current_branch=`git rev-parse --abbrev-ref HEAD`
	if [ "$current_branch" = HEAD ]
	then
		echo "git rev-parse got branch name: HEAD" >&2
		# Scripts might assume this value is correct.  For them, we make it obvious it is not!
		echo "__NO_BRANCH_NAME_FOUND__"
		return 1
	else
		echo "$current_branch"
		return 0
	fi
}

#git_list_all_tracked_files_with_meta() {
#	git ls-tree --full-tree -r HEAD
#	# Add --name-only if you don't want meta; works on bare repo.
#}

git_list_all_tracked_files() {
	# Accept a branch name or commit id
	local tree_arg=''
	if [ -n "$1" ]
	then tree_arg="--with-tree=$1"
	fi
	git ls-files $tree_arg
	# Does not work on bare repos.
}

# Previously called: git_find_branch_start_commit
# Could also be called: git_find_common_commit
git_find_base_commit() {
	local other_branch current_branch

	# It is more likely we want to compare the current branch against an alternative, than to compare an alternative against master.  So we accept the alternative first.
	if [ -n "$1" ]
	then other_branch="$1"
	else other_branch=master
	fi

	# But user may specify the "current" branch second if they wish
	if [ -n "$2" ]
	then current_branch="$2"
	else current_branch=`git_get_current_branch`
	fi
	# Although the order doesn't really matter when passing 2 arguments, since merge-base is symmetric!

	# This is not guaranteed, but the information is likely still in the cache if the branch was created in the last 90 days.
	# In fact it completely fails if you have pulled the branch from a remote repository.  It shows the HEAD at the time that you pulled!
	#git reflog show $current_branch | tail -n 1

	git merge-base "$other_branch" "$current_branch"
}

git_show_base_commit() {
	local commitId=`git_find_base_commit "$@"`

	if [ -n "$commitId" ]
	then
		# These vars have disappeared inside the refactored function :P
		#echo "$current_branch and $other_branch share common commit:"
		#git log --pretty=oneline -1 "$commitId"
		glc -1 "$commitId"
	fi
}

# vim: ft=sh
