--regex-c=/^(COMMENT: C, Java, Javascript, Asm have defaults, so need no langdef, but we can extend them)/\1/X,XXX/

--regex-vim=/^(COMMENT: ex-ctags already has this as 'map': \s*(map|[nvxsoilc]*map)\s+([^\s]*).*)/\2/m,mapping/
--regex-vim=/^(COMMENT: python functions)/\1/X,XXX/
--regex-vim=/^\s*def\s+([a-zA-Z0-9_$]+)/\1/f,function/

--regex-vim=/^(COMMENT: htag matches any *bold* text, so I don't recommend displaying these, but they may still be useful for Ctrl-})/\1/X,XXX/
--regex-vim=/\*([A-Za-z0-9_\-]+)\*/\1/h,htag/
--regex-vim=/^(COMMENT: not needed use augroup)\s*au[tocmd]*\s+[^\s]+\s+([A-Za-z0-9]+)/\1/d,autocmd/

--langmap=c:+.jpp,c:+.uc

--langmap=java:+.jpp,java:+.uc

--langmap=javascript:+.jpp,javascript:+.uc
--regex-javascript=/^(COMMENT: Some of Javascript's default patterns match null on Unrealscript files.)/\1/X,XXX/
--regex-javascript=/^\s*var ([a-zA-Z_$][0-9a-zA-Z_$]*).*$/\1/v,variable/
--regex-javascript=/^\s*module\.exports\.([a-zA-Z_$][0-9a-zA-Z_$]*)\s*=.*$/\1/e,export/
--regex-javascript=/^(BUG: If what is assigned is a function, a later function rule also catches it!  Should we ignore functions, or he ignore 'this'?  In Coffee, he ignores '@' but not 'this'.)/\1/X,XXX/
--regex-javascript=/^\s*this\.([a-zA-Z_$][0-9a-zA-Z_$]*)\s*=.*$/\1/a,assigned/
--regex-javascript=/^\s*([a-zA-Z_$][0-9a-zA-Z_$]*):.*$/\1/p,property/
--regex-javascript=/^(COMMENT: ctags defaults ignore functions inside anonymous functions - the following catch them but can cause duplicates!)/\1/X,XXX/
--regex-javascript=/^(COMMENT: \s*\<function\>\s*(\<[a-zA-Z_$][0-9a-zA-Z_$]*\>) END_COMMENT)/\1/f,function/
--regex-javascript=/^(COMMENT: The following matches functions missed by default, those defined as A.B.f=...  Oh these are now showing up!  Eh I really don't get the pattern.  ctags seems to be catching Project.statics.markDelete just fine on its own, but not ProjectProvider.prototype.findMyProjects!)/\1/X,XXX/
--regex-javascript=/^(COMMENT: \s*([a-zA-Z_$][0-9a-zA-Z_$]*\.[a-zA-Z_$][0-9a-zA-Z_$]*\.[a-zA-Z_$][0-9a-zA-Z_$.]*)*\s*=\s*\<function\> END_COMMENT)/\1/f,function/
--regex-javascript=/^(COMMENT: However, it's worth extracting a tag just for *the last part*, for Ctrl-] in Vim, if not for viewing. END_COMMENT)/\1/f,function/
--regex-javascript=/\s*[a-zA-Z_$][0-9a-zA-Z_$]*\.prototype.([a-zA-Z_$][0-9a-zA-Z_$.]*)*\s*=\s*\<function\>/\1/f,function/
--regex-javascript=/\s*[a-zA-Z_$][0-9a-zA-Z_$]*\.[^p][^r][^o][^t][0-9a-zA-Z_$]*\.([a-zA-Z_$][0-9a-zA-Z_$.]*)*\s*=\s*\<function\>/\1/_,deep_function/
--regex-javascript=/^(COMMENT: But functions assigned to a location with 3 or more dots are not ...)/\1/X,XXX/
--regex-javascript=/^\s*(([a-zA-Z_$][0-9a-zA-Z_$]*\.){3,}[a-zA-Z_$][0-9a-zA-Z_$]*)*\s*=\s*\<function\>/\1/f,function/
--regex-javascript=/^(COMMENT: The following matches functions missed by default, those defined as properties - this assumes you are not already using the 'property' rule above)/\1/X,XXX/
--regex-javascript=/^\s*["']?([a-zA-Z_$][0-9a-zA-Z_$]*)["']?\s*:\s*function\>/\1/f,function/
--regex-javascript=/^(COMMENT: It used to be:)/\1/X,XXX/
--regex-javascript=/^(COMMENT: \s*(\<[a-zA-Z_$][0-9a-zA-Z_$.]*\>)*\s*=\s*\<function\>)/\1/f,function/
--regex-javascript=/^(COMMENT: Express routes: (only if var app is used))/\1/X,XXX/
--regex-javascript=/^\s*\app\.(get|put|post|delete)\(\s*["']([^"']+)["']/\2 (\1)/r,route/

--langdef=opa
--langmap=opa:+.opa
--regex-opa=/^\s*\<type\>\s*(\<[a-zA-Z_$.][0-9a-zA-Z_$.]*\>)/\1/t,type/
--regex-opa=/^\s*\<database\>\s*(\<[a-zA-Z_$.][0-9a-zA-Z_$.]*\>)/\1/d,database/
--regex-opa=/^\s*\<module\>\s*(\<[a-zA-Z_$.][0-9a-zA-Z_$.]*\>)/\1/m,module/
--regex-opa=/^(\<[a-zA-Z_$.][0-9a-zA-Z_$.]*\>)\s*=/\1/g,global/
--regex-opa=/^\s*(client|server|)\s*\<function\>\s*(\<[a-zA-Z_$.][0-9a-zA-Z_$.]*\>)/\2/f,function/

--langdef=man
--langmap=man:+.~,man:+.man
--regex-man=/^(COMMENT: I can't seem to get the ~ extension to match.)/\1/s,section/
--regex-man=/^([A-Z].*)/\1/s,section/

--langdef=uc
--langmap=uc:+.jpp,uc:+.uc
--regex-uc=/^(COMMENT: This is not working, although it does if we put it in the JS rules and set ft=javascript! O_o)/\1/X,XXX/
--regex-uc=/\<state\>\s+([a-zA-Z_$][0-9a-zA-Z_$]*).*$/\1/s,state/

--langdef=coffee
--langmap=coffee:.coffee
--regex-coffee=/^(COMMENT: some of the .*s in below functions are over-optimistic, picking up anonymous callbacks with the wrong =)/\1/X,XXX/
--regex-coffee=/^class @?([a-zA-Z_$][0-9a-zA-Z_$]*)( extends [a-zA-Z_$][0-9a-zA-Z_$]*)?$/\1/c,class/
--regex-coffee=/^(COMMENT: The second case (this|@) is not an export when inside a method, it's just a property assignment. \s*(@|this\.)([a-zA-Z_$][0-9a-zA-Z_$]*)\s*=.*)$/\2/e,export/
--regex-coffee=/^\s*(module\.exports\.)([a-zA-Z_$][0-9a-zA-Z_$]*)\s*=.*$/\2/e,export/
--regex-coffee=/^\s*(@[.]*|this\.)([a-zA-Z_$][0-9a-zA-Z_$]*)\s*=.*$/\2/a,assigned/
--regex-coffee=/^(COMMENT: If you have property enabled, you don't want the next rule)/\1/X,XXX/
--regex-coffee=/^\s*([a-zA-Z_$][0-9a-zA-Z_$]*):[^:]/\1/p,property/
--regex-coffee=/^DISABLED: \s*([a-zA-Z_$][0-9a-zA-Z_$]*):\s*[-=]>.*$/\1/f,function/
--regex-coffee=/^\s*([a-zA-Z_$][0-9a-zA-Z_$.:]*)\s*=.*[-=]>.*$/\1/f,function/
--regex-coffee=/^\s*([a-zA-Z_$][0-9a-zA-Z_$]*)\s*=[^->\n]*$/\1/v,variable/

--langmap=Asm:+.spp
--regex-Asm=/^[^;]*\.macro\s+([a-zA-Z_$][0-9a-zA-Z_$]*)/\1/m,macro/
--regex-Asm=/^[^;]*\.context\s+([a-zA-Z_$][0-9a-zA-Z_$]*)/\1/c,context/
--regex-Asm=/^([A-Za-z0-9_]+):/\1/l,label/

--langdef=dosini
--langmap=dosini:.ini
--regex-dosini=/^\[([^]]*)\]/\1/s,section/

--langdef=haxe
--langmap=haxe:.hx
--regex-haxe=/^package[ \t]+([A-Za-z0-9_.]+)/\1/p,package/
--regex-haxe=/^[ \t]*[(@:macro|private|public|static|override|inline|dynamic)( \t)]*function[ \t]+([A-Za-z0-9_]+)/\1/f,function/
--regex-haxe=/^[ \t]*([private|public|static|protected|inline][ \t]*)+var[ \t]+([A-Za-z0-9_]+)/\2/v,variable/
--regex-haxe=/^[ \t]*package[ \t]*([A-Za-z0-9_]+)/\1/p,package/
--regex-haxe=/^[ \t]*(extern[ \t]*|@:native\([^)]*\)[ \t]*)*class[ \t]+([A-Za-z0-9_]+)[ \t]*[^\{]*/\2/c,class/
--regex-haxe=/^[ \t]*(extern[ \t]+)?interface[ \t]+([A-Za-z0-9_]+)/\2/i,interface/
--regex-haxe=/^[ \t]*typedef[ \t]+([A-Za-z0-9_]+)/\1/t,typedef/
--regex-haxe=/^[ \t]*enum[ \t]+([A-Za-z0-9_]+)/\1/t,typedef/
--regex-haxe=/^[ \t]*+([A-Za-z0-9_]+)(;|\([^)]*:[^)]*\))/\1/t,enum_field/

--langdef=haxe-sws
--langmap=haxe-sws:.hx.sws
--regex-haxe-sws=/^package[ \t]+([A-Za-z0-9_.]+)/\1/p,package/
--regex-haxe-sws=/^[ \t]*[(@:macro|private|public|static|override|inline|dynamic)( \t)]*function[ \t]+([A-Za-z0-9_]+)/\1/f,function/
--regex-haxe-sws=/^[ \t]*([private|public|static|protected|inline][ \t]*)+var[ \t]+([A-Za-z0-9_]+)/\2/v,variable/
--regex-haxe-sws=/^[ \t]*package[ \t]*([A-Za-z0-9_]+)/\1/p,package/
--regex-haxe-sws=/^[ \t]*(extern[ \t]*|@:native\([^)]*\)[ \t]*)*class[ \t]+([A-Za-z0-9_]+)[ \t]*[^\{]*/\2/c,class/
--regex-haxe-sws=/^[ \t]*(extern[ \t]+)?interface[ \t]+([A-Za-z0-9_]+)/\2/i,interface/
--regex-haxe-sws=/^[ \t]*typedef[ \t]+([A-Za-z0-9_]+)/\1/t,typedef/
--regex-haxe-sws=/^[ \t]*enum[ \t]+([A-Za-z0-9_]+)/\1/t,typedef/
--regex-haxe-sws=/^[ \t]*+([A-Za-z0-9_]+)(;|\([^)]*:[^)]*\))/\1/t,enum_field/

--langdef=joeygrammar
--langmap=joeygrammar:.grm
--regex-joeygrammar=/^\s*([A-Za-z0-9_$@]*)\s*=/\1/r,rule/

--langdef=haskell
--langmap=haskell:.hs
--regex-haskell=/^(COMMENT: matching = may miss functions declared with pattern matching, however those will tend to throw up multiple results which will be annoying.  We could seek :: but these are optional - the favourite probably depends on the style of the file you are editing.)/\1/X,XXX/
--regex-haskell=/^([a-zA-Z_][a-zA-Z0-9_]*)\s*::.*/\1/s,signature/
--regex-haskell=/^(WARNING: Patterns can produce multiple entries, and this regexp also accidentally catches data and type lines too!)/\1/X,XXX/
--regex-haskell=/^data ([a-zA-Z_][a-zA-Z0-9_]*)/\1/d,data/
--regex-haskell=/^type ([a-zA-Z_][a-zA-Z0-9_]*)/\1/t,type/
--regex-haskell=/^([a-zA-Z_][a-zA-Z0-9_]*)\s*=.*/\1/f,function/
--regex-haskell=/^([a-zA-Z_][a-zA-Z0-9_]*)\s+[^=:].*=/\1/p,pattern/
--regex-haskell=/^(COMMENT: Argh, we could just go for signature and other (anything with =)!)/\1/X,XXX/
--regex-haskell=/^DISABLED: ([a-zA-Z_][a-zA-Z0-9_]*)\s+[^=:].*=/\1/d,definition/
--regex-haskell=/^(COMMENT: Probably what we really want is one entry (the top one) instead of multiple pattern entries.)/\1/X,XXX/

--langdef=markdown
--langmap=markdown:.md
--regex-markdown=/^(#[^#].*)/\1/1,level1/
--regex-markdown=/^(##[^#].*)/\1/2,level2/
--regex-markdown=/^(###[^#].{0,19})/\1/3,level3/
--regex-markdown=/^(=[^=].*)/\1/1,level1/
--regex-markdown=/^(==[^=].*)/\1/2,level2/
--regex-markdown=/^(===[^=].{0,19})/\1/3,level3/

--langdef=help
--langmap=help:.txt
--regex-help=/^([0-9]+\. [A-Z].*)\*$/\1/s,section/
--regex-help=/^COMMENT: ([A-Z][A-Za-z0-9 ]*).*\*.+\*$/\1/h,heading/
--regex-help=/^([A-Z][A-Za-z0-9 ]*)\s+\*.+\*/\1/h,heading/
--regex-help=/[\*]([^* \t]+)[\*]$/\1/m,marker/

--langdef=Scala
--langmap=Scala:.scala
--regex-Scala=/^\s*class\s*([a-zA-Z0-9_]+)/\1/c,class/
--regex-Scala=/^\s*object\s*([a-zA-Z0-9_]+)/\1/o,object/
--regex-Scala=/^\s*trait\s*([a-zA-Z0-9_]+)/\1/t,trait/
--regex-Scala=/^\s*case\s*class\s*([a-zA-Z0-9_]+)/\1/r,cclass/
--regex-Scala=/^\s*abstract\s*class\s*([a-zA-Z0-9_]+)/\1/a,aclass/
--regex-Scala=/^\s*((private|override)\s+)*def\s*([a-zA-Z0-9_=]+)\s*.*[:=]/\1/m,method/
--regex-Scala=/\s*val\s*([a-zA-Z0-9_]+)\s*[:=]/\1/V,value/
--regex-Scala=/\s*var\s*([a-zA-Z0-9_]+)\s*[:=]/\1/v,variable/
--regex-Scala=/^\s*type\s*([a-zA-Z0-9_]+)\s*[\[<>=]/\1/T,type/
--regex-Scala=/^\s*import\s*([a-zA-Z0-9_{}., \t=>]+$)/\1/i,include/
--regex-Scala=/^\s*package\s*([a-zA-Z0-9_.]+$)/\1/p,package/

--langmap=html:+.erb
--regex-html=/^\s*<template name=["']([^"']*)./\1/t,template/
--regex-html=/^\<id=["']([^"']*)./\1/i,id/

