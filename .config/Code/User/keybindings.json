// Place your key bindings in this file to override the defaults
// prettier-ignore
[
  // When composing "when" conditions, you may like to view what is available, using:
  //     >Developer: Toggle Developer Tools
  //     and
  //     >Developer: Inspect Context Keys
  // https://code.visualstudio.com/api/references/when-clause-contexts
  //
  { "key": "alt+cmd+j", "command": "workbench.action.toggleDevTools" },
  { "key": "meta+alt+j", "command": "workbench.action.toggleDevTools" },
  { "key": "ctrl+shift+j", "command": "workbench.action.toggleDevTools" },

  /*
  // Walk through search results with Alt-Up/Down (VSCode default is F4, Shift-F4)
  { "key": "alt+down", "command": "goToNextReferenceFromEmbeddedEditor", "when": "inReferenceSearchEditor" },
  { "key": "alt+up", "command": "goToPreviousReferenceFromEmbeddedEditor", "when": "inReferenceSearchEditor" },
  { "key": "alt+down", "command": "search.action.focusNextSearchResult", "when": "hasSearchResult" },
  { "key": "alt+up", "command": "search.action.focusPreviousSearchResult", "when": "hasSearchResult" },
  { "key": "alt+down", "command": "goToNextReference", "when": "referenceSearchVisible" },
  { "key": "alt+up", "command": "goToPreviousReference", "when": "referenceSearchVisible" },

  { "key": "ctrl+g", "command": "editor.action.nextMatchFindAction", "when": "editorFocus" },
  { "key": "ctrl+shift+g", "command": "editor.action.previousMatchFindAction", "when": "editorFocus" },
  { "key": "ctrl+l", "command": "workbench.action.gotoLine" },
  { "key": "ctrl+backspace", "command": "deleteRight", "when": "textInputFocus && !editorReadonly" },
  { "key": "ctrl+shift+j", "command": "editor.action.joinLines", "when": "editorFocus" },
  */

  { "key": "ctrl+=", "command": "editor.action.fontZoomIn" },
  { "key": "ctrl+-", "command": "editor.action.fontZoomOut" },
  { "key": "ctrl+0", "command": "editor.action.fontZoomReset" },
  { "key": "ctrl+shift+=", "command": "workbench.action.zoomIn" },
  { "key": "ctrl+shift+-", "command": "workbench.action.zoomOut" },
  { "key": "ctrl+shift+0", "command": "workbench.action.zoomReset" },

  { "key": "meta+up", "command": "editor.action.addSelectionToNextFindMatch", "when": "editorFocus" },

  /*
  { "key": "alt+z", "command": "workbench.action.maximizeEditor" },
  */

  { "key": "ctrl+shift+\\", "command": "workbench.action.splitEditorOrthogonal" },

  { "key": "alt+w", "command": "workbench.action.closeWindow", "when": "!editorIsOpen && !multipleEditorGroups" },

  /* ==== Make keybindings the same on Linux and macOS ==== {{{ */

  // Navigation like WebStorm on Mac
  { "key": "alt+shift+[", "command": "workbench.action.previousEditor", "when": "!terminalFocus" },
  { "key": "alt+shift+]", "command": "workbench.action.nextEditor", "when": "!terminalFocus" },
  { "key": "alt+[", "command": "workbench.action.navigateBack" },
  { "key": "alt+]", "command": "workbench.action.navigateForward" },
  { "key": "ctrl+alt+[", "command": "workbench.action.navigateBack" },
  { "key": "ctrl+alt+]", "command": "workbench.action.navigateForward" },

  // Text movement and selection like Mac (beginning/end of file not done)
  { "key": "alt+right", "command": "cursorEnd", "when": "textInputFocus" },
  { "key": "alt+shift+right", "command": "cursorEndSelect", "when": "textInputFocus" },
  { "key": "alt+left", "command": "cursorHome", "when": "textInputFocus" },
  { "key": "alt+shift+left", "command": "cursorHomeSelect", "when": "textInputFocus" },
  { "key": "meta+right", "command": "cursorWordEndRight", "when": "textInputFocus" },
  { "key": "meta+shift+right", "command": "cursorWordEndRightSelect", "when": "textInputFocus" },
  { "key": "meta+left", "command": "cursorWordStartLeft", "when": "textInputFocus" },
  { "key": "meta+shift+left", "command": "cursorWordStartLeftSelect", "when": "textInputFocus" },
  { "key": "alt+shift+down", "command": "editor.action.moveLinesDownAction", "when": "editorTextFocus && !editorReadonly" },
  { "key": "alt+shift+up", "command": "editor.action.moveLinesUpAction", "when": "editorTextFocus && !editorReadonly" },

  /* To match Linux keybinds on macOS */
  { "key": "ctrl+shift+p", "command": "workbench.action.showCommands" },

  { "key": "ctrl+pageup", "command": "workbench.action.terminal.focusPrevious", "when": "terminalFocus && terminalHasBeenCreated && !terminalEditorFocus || terminalFocus && terminalProcessSupported && !terminalEditorFocus" },
  { "key": "ctrl+pagedown", "command": "workbench.action.terminal.focusNext", "when": "terminalFocus && terminalHasBeenCreated && !terminalEditorFocus || terminalFocus && terminalProcessSupported && !terminalEditorFocus" },
  { "key": "ctrl+pageup", "command": "workbench.action.debug.prevConsole", "when": "inDebugRepl" },
  { "key": "ctrl+pagedown", "command": "workbench.action.debug.nextConsole", "when": "inDebugRepl" },

  /* ==== Make Linux match macOS keybinds ==== {{{ */

  /*
  // Text manipulation like Mac
  // Note: There are a lot of definitions for ctrl+c, but we have only mirrored the main one so far.
  { "key": "alt+c", "command": "editor.action.clipboardCopyAction", "when": "textInputFocus" },
  { "key": "alt+x", "command": "editor.action.clipboardCutAction", "when": "textInputFocus && !editorReadonly" },
  { "key": "alt+v", "command": "editor.action.clipboardPasteAction", "when": "textInputFocus && !editorReadonly" },
  { "key": "alt+/", "command": "editor.action.commentLine", "when": "editorTextFocus && !editorReadonly" },
  */

  { "key": "alt+z", "command": "undo", "when": "textInputFocus && !editorReadonly" },
  { "key": "alt+shift+z", "command": "redo", "when": "textInputFocus && !editorReadonly" },

  // Some of these mimic WebStorm
  { "key": "meta+shift-f", "command": "editor.action.formatDocument", "when": "editorTextFocus && !editorReadonly" },
  { "key": "meta+shift+o", "command": "editor.action.organizeImports", "when": "editorTextFocus && !editorReadonly && supportedCodeAction =~ /(\\s|^)source\\.organizeImports\\b/" },
  { "key": "alt-j", "command": "workbench.action.togglePanel" },
  { "key": "alt-p", "command": "workbench.action.quickOpen" },
  { "key": "alt+p", "command": "workbench.action.quickOpenNavigateNextInFilePicker", "when": "inFilesPicker && inQuickOpen" },
  { "key": "alt+shift+p", "command": "workbench.action.quickOpenNavigatePreviousInFilePicker", "when": "inFilesPicker && inQuickOpen" },
  { "key": "alt+shift+p", "command": "workbench.action.showCommands", "when": "!inFilesPicker || !inQuickOpen" },
  { "key": "alt+shift+e", "command": "workbench.view.explorer" },
  // To train me to use Cmd-P / Alt-P instead of Ctrl-P
  { "key": "ctrl+p", "command": "-workbench.action.quickOpen" },
  { "key": "alt+shift+f", "command": "workbench.view.search", "when": "!searchViewletVisible" },
  { "key": "alt+backspace", "command": "editor.action.deleteLines", "when": "textInputFocus && !editorReadonly" },
  // I am now using the default (Opt-Shift-F on Mac, Ctrl-Shift-I on Linux)
  /*
  { "key": "alt+shift+l", "command": "editor.action.formatDocument", "when": "editorTextFocus && !editorReadonly" },
  { "key": "alt+shift+p", "command": "editor.action.formatDocument", "when": "editorTextFocus && !editorReadonly" },
  { "key": "ctrl+alt+shift+p", "command": "editor.action.formatDocument", "when": "editorTextFocus && !editorReadonly" },
  */

  // Cmd-[ and Cmd-] should not adjust line indent, but instead navigate back/forwards
  { "key": "cmd+[", "command": "-editor.action.outdentLines", "when": "editorTextFocus && !editorReadonly" },
  { "key": "cmd+]", "command": "-editor.action.indentLines", "when": "editorTextFocus && !editorReadonly" },
  { "key": "cmd+[", "command": "workbench.action.navigateBack", "when": "canNavigateBack" },
  { "key": "cmd+]", "command": "workbench.action.navigateForward", "when": "canNavigateForward" },
  { "key": "alt+[", "command": "workbench.action.navigateBack", "when": "canNavigateBack" },
  { "key": "alt+]", "command": "workbench.action.navigateForward", "when": "canNavigateForward" },

  // On Linux ctrl+shift+e should trigger "workbench.view.explorer" but GTK might hijack it for a new emoji feature.
  // If you want it back, you may try to disable GTK's hijacking: https://github.com/microsoft/vscode/issues/48480

  //{ "key": "alt+s", "command": "workbench.action.files.save" },
  { "key": "alt+s", "command": "workbench.action.files.saveAll" },
  { "key": "ctrl+s", "command": "workbench.action.files.saveAll" },

  // Disable these VSCode defaults, because I need to use these keys in Vim mode
  { "key": "ctrl+w", "command": "-workbench.action.closeWindow", "when": "!editorIsOpen && !multipleEditorGroups" },
  { "key": "ctrl+w", "command": "-workbench.action.closeGroup", "when": "activeEditorGroupEmpty && multipleEditorGroups" },
  { "key": "ctrl+w", "command": "-workbench.action.closeActiveEditor", "when": "editorFocus" },
  /* Enable it only when there is one window pane (no splits) */
  //{ "key": "ctrl+w", "command": "workbench.action.closeActiveEditor", "when": "editorFocus && !multipleEditorGroups" },

  // Disable these Vim defaults, because I don't use them, and I would rather use the VSCode shortcuts
  { "key": "ctrl+f", "command": "-extension.vim_ctrl+f", "when": "editorTextFocus && vim.active && vim.use<C-f> && !inDebugRepl && vim.mode != 'Insert'" },

  // Disable Vim's CTRL-X, so we get normal cut back
  { "key": "ctrl+x", "command": "-extension.vim_ctrl+x", "when": "editorTextFocus && vim.active && vim.use<C-x> && !inDebugRepl" },

  { "key": "alt+shift+f", "command": "workbench.action.findInFiles" },
  // Oddly, while there was a System setting like this on macOS, it didn't work until I created an identical user setting
  { "key": "cmd+shift+f", "command": "workbench.action.findInFiles" },
  // Let's also put it on this
  { "key": "ctrl+shift+f", "command": "workbench.action.findInFiles" },

  //{ "key": "ctrl+n", "command": "!extension.vim_ctrl+n", "when": "editorTextFocus && vim.active && vim.use<C-n> && !inDebugRepl || vim.active && vim.use<C-n> && !inDebugRepl && vim.mode == 'CommandlineInProgress' || vim.active && vim.use<C-n> && !inDebugRepl && vim.mode == 'SearchInProgressMode'" },
  //{ "key": "ctrl+p", "command": "!extension.vim_ctrl+p", "when": "suggestWidgetVisible && vim.active && vim.use<C-p> && !inDebugRepl || vim.active && vim.use<C-p> && !inDebugRepl && vim.mode == 'CommandlineInProgress' || vim.active && vim.use<C-p> && !inDebugRepl && vim.mode == 'SearchInProgressMode'" },

  //{ "key": "ctrl+n", "command": "search.action.focusNextSearchResult", "when": "hasSearchResult" },
  //{ "key": "ctrl+p", "command": "search.action.focusPreviousSearchResult", "when": "hasSearchResult" },

  // It looks like when multiple bindings match, it uses the later one
  { "key": "alt+meta+down", "command": "references-view.next", "when": "reference-list.hasResult && references-view.canNavigate" },
  { "key": "alt+meta+up", "command": "references-view.prev", "when": "reference-list.hasResult && references-view.canNavigate" },
  { "key": "alt+meta+down", "command": "search.action.focusNextSearchResult", "when": "hasSearchResult || inSearchEditor" },
  { "key": "alt+meta+up", "command": "search.action.focusPreviousSearchResult", "when": "hasSearchResult || inSearchEditor" },
  // If multiple "when"s match, VSCode seems to prefer the later one, i.e. search above.
  // So if I really want references instead of search results, I'll hold down shift.
  { "key": "shift+alt+meta+down", "command": "references-view.next", "when": "reference-list.hasResult" },
  { "key": "shift+alt+meta+up", "command": "references-view.prev", "when": "reference-list.hasResult" },
  // There is reference-list.isActive but that is always true, and referenceSearchVisible but that is always false
  // So it seems neither of those refer to the visibiility of the sidebar panel, which is what I'm interested in
  //
  // VSCode's finder currently loses your position in the search results if you edit the line for the current result, or one of the line above it in the file.
  // This is really annoying!  Using search.action.remove on every result can help with this, because it drops the current result, so if you do lose your place, you won't need to visit this discarded line again.
  // Default: Ctrl/Cmd-Backspace but that does something destructive if the editor is focused
  //{ "key": "alt+meta+right", "command": "search.action.remove", "when": "hasSearchResult || inSearchEditor" },
  { "key": "alt+meta+right", "command": "runCommands", "args": { "commands": [ "search.action.focusSearchList", "search.action.remove" ] }, "when": "hasSearchResult || inSearchEditor" },
  //
  // BUG: Since Feb/March 2025, using F4 or alt+meta+down results in the search text being selected. I don't want this!
  // I tried to cancel the text selection, but this still kept it selected
  //{ "key": "alt+meta+down", "command": "runCommands", "args": { "commands": [ "search.action.focusNextSearchResult", "workbench.action.focusActiveEditorGroup", "setSelection", "cancelSelection", "editor.action.cancelSelectionAnchor", "cursorEndSelect", "removeSecondaryCursors" ] }, "when": "hasSearchResult || inSearchEditor" },
  // Undoing these didn't make any difference (and certainly wouldn't to F4)
  //{ "key": "alt+meta+down", "command": "-editor.action.insertCursorBelow", "when": "editorTextFocus" },
  //{ "key": "alt+meta+up", "command": "-editor.action.insertCursorAbove", "when": "editorTextFocus" },
  //{ "key": "alt+cmd+down", "command": "-editor.action.insertCursorBelow", "when": "editorTextFocus" },
  //{ "key": "alt+cmd+up", "command": "-editor.action.insertCursorAbove", "when": "editorTextFocus" },

  // Cursor disabled this (perhaps for good reason, because cmd+k is a Cursor feature: inline chat)
  // But if we want to re-enable it, we can do that here:
  { "key": "cmd+k cmd+t", "command": "workbench.action.selectTheme" },

  // When focused on search, get back to editor by pressing Escape
  // I couldn't find a "when" for when the references results are focused, so I would like to enable this always.
  // But if I use an empty "when" then I cannot escape from Vim's insert mode.
  { "key": "escape", "command": "workbench.action.focusActiveEditorGroup", "when": "searchInputBoxFocus" },
  // One of the popups is difficult to get rid of.  Well it's possible with Shift-Escape (or Shift-Escape via Ctrl-L) but I just want Escape to remove it.
  // I'm not sure which popup it is exactly, because there are a lot bound to Shift-Escape.  (So it might not be the suggestionWidget at all.)
  // This attempt was problematic because, when autocomplete menu is focused, usually <Escape> will also break out of Vim's INSERT mode.  With this keybinding enabled, <Escape> closes the autocomplete menu, but it didn't leave INSERT mode.
  //{ "key": "escape", "command": "hideSuggestWidget", "when": "suggestWidgetVisible && textInputFocus" },

  // When focused on file explorer, get back to editor by pressing Escape
  { "key": "escape", "command": "workbench.action.focusActiveEditorGroup", "when": "explorerViewletVisible && filesExplorerFocus && !inputFocus" },

  // A catch all, which should leave the sidebar whenever focus is there
  // The case I needed this was after `gU` aka `references-view.find`
  { "key": "escape", "command": "workbench.action.focusActiveEditorGroup", "when": "!editorFocus && !terminalFocus && !terminalFindFocus && !inputFocus" },
  // It might be preferable to whitelist when we do want this to happen, rather than blacklist, but inventing this state boolean didn't work for me
  //{ "key": "escape", "command": "workbench.action.focusActiveEditorGroup", "when": "sidebarFocus" },

  { "key": "alt+k alt+t", "command": "workbench.action.selectTheme" },
  // Because tortilla maps Alt-T to Ctrl-T
  { "key": "alt+k ctrl+t", "command": "workbench.action.selectTheme" },

  /* }}} */

  /* ==== Autocomplete ==== {{{ */

  // Use Tab to open autocomplete suggestions, and cycle through them
  // This sometimes doesn't work, but we fall back to "editor.tabCompletion" to open the suggestion list
  { "key": "tab", "command": "editor.action.triggerSuggest", "when": "editorHasCompletionItemProvider && textInputFocus && !editorReadonly && atEndOfWord" },
  // This is helpful if "editor.tabCompletion" is "off" but it prevents us from inserting real Tabs onto an empty line
  //{ "key": "tab", "command": "editor.action.triggerSuggest", "when": "editorHasCompletionItemProvider && textInputFocus && !editorReadonly" },
  //{ "key": "tab", "command": "selectNextSuggestion", "when": "suggestWidgetMultipleSuggestions && suggestWidgetVisible && textInputFocus" },
  //{ "key": "shift-tab", "command": "selectPrevSuggestion", "when": "suggestWidgetMultipleSuggestions && suggestWidgetVisible && textInputFocus" },
  { "key": "tab", "command": "selectNextSuggestion", "when": "suggestWidgetVisible && textInputFocus" },
  { "key": "shift-tab", "command": "selectPrevSuggestion", "when": "suggestWidgetVisible && textInputFocus" },

  // This was useful while I was retraining. The old way (VSCode's default?) focuses the first suggestion and then let's us hit Enter to accept it.
  // But with my new setup, since nothing is focused, hitting Enter would ignore the suggestion widget, and accidentally start a new line!
  // This keybind would accept the suggestion if one was selected (e.g. Tab then Enter)
  // If no suggestion was selected, it would do nothing, successfully blocking the creation of a new line, which was good.
  //{ "key": "enter", "command": "acceptSelectedSuggestion", "when": "suggestWidgetVisible && textInputFocus" },
  // At one point, without this, Tab-Enter would select the suggestion but then discard it and start a new line!
  //
  // 20250516: Now that I have adapted to the new style (close to Vim's style) I actually _want_ Enter to start a new line!
  // So I have disabled this keybind.
  // And anyway, I'm no longer having the Tab-Enter problem mentioned above.

  // 20250516: On the same day, if the suggestions were visible, pressing Escape would close the suggestion list but NOT exist Insert mode. I want it to leave Insert mode, so I changed VSCodeVim's keybind below
  {
    "key": "escape",
    "command": "extension.vim_escape",
    // Original
    //"when": "editorTextFocus && vim.active && !dirtyDiffVisible && !inDebugRepl && !inlineEditIsVisible && !inlineSuggestionVisible && !notebookEditorFocused && !suggestWidgetVisible && !testing.isInPeek && !testing.isPeekVisible || editorTextFocus && vim.active && !dirtyDiffVisible && !inDebugRepl && !inlineEditIsVisible && !inlineSuggestionVisible && !suggestWidgetVisible && !testing.isInPeek && !testing.isPeekVisible && vim.mode == 'Insert'"
    // My fix removed some of the !*Visible conditions
    "when": "editorTextFocus && vim.active && !dirtyDiffVisible && !inDebugRepl && !notebookEditorFocused && !testing.isInPeek && !testing.isPeekVisible || editorTextFocus && vim.active && !dirtyDiffVisible && !inDebugRepl && !testing.isInPeek && !testing.isPeekVisible && vim.mode == 'Insert'"
  },

  // Act more like Vim, by accepting the current suggestion, if we keep typing
  { "key": "space", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": " "} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": ".", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "."} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": ",", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": ","} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": ";", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": ";"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "shift-;", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": ":"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  // ( and )
  { "key": "shift-9", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "("} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "shift-0", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": ")"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "[", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "["} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "]", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "]"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "shift-[", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "{"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "shift-]", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "}"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "'", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "'"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  // I put text: "" for this one, because VSCode likes to enter two quotes instead of one
  { "key": "shift-'", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": ""} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "`", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "`"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  // ! and ?
  { "key": "shift-1", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "!"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "shift-/", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "?"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "/", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "/"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "'", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "'"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  // < and >
  { "key": "shift-,", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "<"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "shift-.", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": ">"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },

  //{ "key": "tab", "command": "acceptSelectedSuggestion", "when": "acceptSuggestionOnEnter && suggestWidgetVisible && suggestionMakesTextEdit && textInputFocus" },

  /* }}} */

  // Use Tab to cycle whenever a list is focused
  // I find this useful when jumping to a definition, when multiple suggestions are offered
  { "key": "tab", "command": "list.focusDown", "when": "listFocus" },
  { "key": "shift-tab", "command": "list.focusUp", "when": "listFocus" },

  // More lists that should use Tab to cycle
  { "key": "tab", "command": "selectNextCodeAction", "when": "codeActionMenuVisible" },
  { "key": "shift-tab", "command": "selectPrevCodeAction", "when": "codeActionMenuVisible" },
  { "key": "tab", "command": "showNextParameterHint", "when": "editorFocus && parameterHintsMultipleSignatures && parameterHintsVisible && !suggestWidgetVisible" },
  { "key": "shift-tab", "command": "showPrevParameterHint", "when": "editorFocus && parameterHintsMultipleSignatures && parameterHintsVisible && !suggestWidgetVisible" },

  // Using VSCodeVim, when focused on the explorer/sidebar I would often try to use `Ctrl-W Right` to get back to the editor.
  // But in VSCode, Ctrl+W closes the current editor!  So I made this mapping to intercept that.
  { "key": "ctrl+w Right", "command": "workbench.action.focusActiveEditorGroup", "when": "explorerViewletVisible && filesExplorerFocus && !inputFocus" },
  { "key": "ctrl+w l", "command": "workbench.action.focusActiveEditorGroup", "when": "explorerViewletVisible && filesExplorerFocus && !inputFocus" },
  { "key": "ctrl+[", "command": "workbench.action.focusActiveEditorGroup", "when": "explorerViewletVisible && filesExplorerFocus && !inputFocus" },
  { "key": "] w", "command": "workbench.action.focusActiveEditorGroup", "when": "explorerViewletVisible && filesExplorerFocus && !inputFocus" },

  /* Cycle zoom (requires Settings Cycler plugin) */
  /* I use this because I like -0.5 on my Linux, but Ctrl-Plus/Minus round to integers */
  {
    "key": "ctrl+shift+0",
    "command": "settings.cycle",
    //"when": "editorTextFocus",
    "args": {
      "id": "cycleResetZoom", // must be unique
      "overrideWorkspaceSettings": true,
      "values": [
        {
          //"window.zoomLevel": -0.5
          "window.zoomLevel": -0.8
        },
        {
          //"window.zoomLevel": -0.8
          "window.zoomLevel": -1
        },
        {
          //"window.zoomLevel": 0
          "window.zoomLevel": -0.5
        }
      ]
    }
  },

  // Cycle theme
  {
    "key": "cmd+k cmd+k",
    "command": "settings.cycle",
    "args": {
      "id": "cycleColorTheme", // must be unique
      "overrideWorkspaceSettings": true,
      "values": [
        // This is mine, it's nice and calm, but a bit boring
        { "workbench.colorTheme": "Gentle Mary" },
        { "workbench.colorTheme": "Atom Material Theme" },
        { "workbench.colorTheme": "Tokyo Night" },
        { "workbench.colorTheme": "Black Rock" },
        // These looks cool
        { "workbench.colorTheme": "Night Wolf (gray)" },
        { "workbench.colorTheme": "SynthWave '84" },
        // These lighter themes are good when working in bright conditions
        { "workbench.colorTheme": "Quiet Light" },
        { "workbench.colorTheme": "Visual Studio Light" },
        //{ "workbench.colorTheme": "Default Light +" },
        { "workbench.colorTheme": "Default Light Modern" },
        //{ "workbench.colorTheme": "Community Material Theme Lighter" },
        //{ "workbench.colorTheme": "Community Material Theme Lighter High Contrast" },
      ]
    }
  },
  {
    "key": "alt+k alt+k",
    "command": "settings.cycle",
    "args": {
      "id": "cycleColorTheme", // must be unique
      "overrideWorkspaceSettings": true,
      "values": [
        // This is mine, it's nice and calm, but a bit boring
        { "workbench.colorTheme": "Gentle Mary" },
        { "workbench.colorTheme": "Atom Material Theme" },
        { "workbench.colorTheme": "Tokyo Night" },
        { "workbench.colorTheme": "Black Rock" },
        // These looks cool
        { "workbench.colorTheme": "Night Wolf (gray)" },
        { "workbench.colorTheme": "SynthWave '84" },
        // These lighter themes are good when working in bright conditions
        { "workbench.colorTheme": "Quiet Light" },
        { "workbench.colorTheme": "Visual Studio Light" },
        //{ "workbench.colorTheme": "Default Light +" },
        { "workbench.colorTheme": "Default Light Modern" },
        //{ "workbench.colorTheme": "Community Material Theme Lighter" },
        //{ "workbench.colorTheme": "Community Material Theme Lighter High Contrast" },
      ]
    }
  },
  // The following was only needed when we had bound Cmd-K Cmd-T Cmd-T above
  // Since the above overrode the default Cmd-K Cmd-T, then let's create a new bind for it
  //{ "key": "cmd+k cmd+t cmd+k", "command": "workbench.action.selectTheme" },

  { "key": "ctrl+e", "command": "workbench.action.showAllEditorsByMostRecentlyUsed", "when": "editorTextFocus && vim.active && vim.use<C-]> && !inDebugRepl" },
  { "key": "ctrl+b", "command": "workbench.action.showEditorsInActiveGroup", "when": "editorTextFocus && vim.active && vim.use<C-]> && !inDebugRepl" },

  // When you want to insert a literal tab
  { "key": "ctrl+v tab", "command": "type", "args": { "text": "\t" }, "when": "editorTextFocus" },

  // VSCode now has good defaults for these (that work well when the terminal has been dragged into an editor tab)
  //{ "key": "ctrl+PageUp", "command": "workbench.action.terminal.focusPrevious", "when": "terminalFocus" },
  //{ "key": "ctrl+PageDown", "command": "workbench.action.terminal.focusNext", "when": "terminalFocus" },

  { "key": "ctrl+alt+shift+l", "command": "editor.action.formatDocument.multiple" },
  { "key": "ctrl+alt+shift+l", "command": "eslint.executeAutofix" },
  { "key": "ctrl+alt+shift+o", "command": "editor.action.organizeImports", "when": "editorTextFocus && !editorReadonly && supportedCodeAction =~ /(\\s|^)source\\.organizeImports\\b/" },

  // We can reach the Terminal with <Ctrl-W> <Down>, so we should be able to leave it with <Ctrl-W> <Up>
  // This might not go back where you were before, if you have multiple editor groups open (split windows)
  // (Sometimes I move the terminal to the left or right or the editors, so I define more keys)
  { "key": "ctrl+w Up", "command": "workbench.action.focusPreviousGroup", "when": "terminalFocus" },
  { "key": "ctrl+w k", "command": "workbench.action.focusPreviousGroup", "when": "terminalFocus" },
  { "key": "ctrl+w Left", "command": "workbench.action.focusPreviousGroup", "when": "terminalFocus" },
  { "key": "ctrl+w h", "command": "workbench.action.focusPreviousGroup", "when": "terminalFocus" },
  { "key": "ctrl+w Down", "command": "workbench.action.focusNextGroup", "when": "terminalFocus" },
  { "key": "ctrl+w j", "command": "workbench.action.focusNextGroup", "when": "terminalFocus" },
  { "key": "ctrl+w Right", "command": "workbench.action.focusNextGroup", "when": "terminalFocus" },
  { "key": "ctrl+w l", "command": "workbench.action.focusNextGroup", "when": "terminalFocus" },
  // More useful keys for the terminal
  { "key": "ctrl+w c", "command": "workbench.action.terminal.toggleTerminal", "when": "terminalFocus" },
  // This only works when the panel is aligned centrally
  { "key": "ctrl+z", "command": "workbench.action.toggleMaximizedPanel", "when": "terminalFocus" },
  // Trying to make it easy to re-align the panel, when I want to toggle maximization
  // Unfortunately these rarely trigger
  // , "when": "terminalFocus"
  //{ "key": "ctrl+a", "command": "workbench.action.alignPanelLeft" },
  //{ "key": "ctrl+x", "command": "workbench.action.positionPanelBottom" },

  // In my Terminal, I use Ctrl-F to move forward one word, so I want Find to be on Ctrl-Shift-F instead.
  { "key": "ctrl+f", "command": "-workbench.action.terminal.focusFind", "when": "terminalFindFocused && terminalHasBeenCreated || terminalFindFocused && terminalProcessSupported || terminalFocus && terminalHasBeenCreated || terminalFocus && terminalProcessSupported" },
  { "key": "ctrl+shift+f", "command": "workbench.action.terminal.focusFind", "when": "terminalFindFocused && terminalHasBeenCreated || terminalFindFocused && terminalProcessSupported || terminalFocus && terminalHasBeenCreated || terminalFocus && terminalProcessSupported" },

  // Experiment: I was trying to complement the C-L binding in settings.json
  // Result: This runs before, not after, the VSCodeVim binding
  // Another result we found is that, both here and there, if we define two bindings with the same key and same when, then the second binding one overwrites the first.
  //{ "key": "ctrl+l", "command": "workbench.action.toggleSidebarVisibility", "when": "sideBarVisible" },

  { "key": "shift+f10", "command": "editor.action.inspectTMScopes" },

  { "key": "cmd+1", "command": "-workbench.action.focusFirstEditorGroup" },
  { "key": "cmd+2", "command": "-workbench.action.focusSecondEditorGroup" },
  { "key": "cmd+3", "command": "-workbench.action.focusThirdEditorGroup" },
  { "key": "cmd+4", "command": "-workbench.action.focusFourthEditorGroup" },
  { "key": "cmd+5", "command": "-workbench.action.focusFifthEditorGroup" },
  { "key": "cmd+6", "command": "-workbench.action.focusSixthEditorGroup" },
  { "key": "cmd+7", "command": "-workbench.action.focusSeventhEditorGroup" },
  { "key": "cmd+8", "command": "-workbench.action.focusEighthEditorGroup" },
  { "key": "cmd+9", "command": "-workbench.action.focusLastEditorGroup" },
  { "key": "cmd+1", "command": "workbench.action.openEditorAtIndex1" },
  { "key": "cmd+2", "command": "workbench.action.openEditorAtIndex2" },
  { "key": "cmd+3", "command": "workbench.action.openEditorAtIndex3" },
  { "key": "cmd+4", "command": "workbench.action.openEditorAtIndex4" },
  { "key": "cmd+5", "command": "workbench.action.openEditorAtIndex5" },
  { "key": "cmd+6", "command": "workbench.action.openEditorAtIndex6" },
  { "key": "cmd+7", "command": "workbench.action.openEditorAtIndex7" },
  { "key": "cmd+8", "command": "workbench.action.openEditorAtIndex8" },
  { "key": "cmd+9", "command": "workbench.action.openEditorAtIndex9" },

  // Before adding these, on macOS, Ctrl-PageUp/Down were only working on editor windows, not on UI windows
  { "key": "ctrl+pageup", "command": "workbench.action.previousEditor", "when": "!terminalFocus" },
  { "key": "ctrl+pagedown", "command": "workbench.action.nextEditor", "when": "!terminalFocus" },
  //
  { "key": "ctrl+shift+pageup", "command": "workbench.action.moveEditorLeftInGroup" },
  { "key": "ctrl+shift+pagedown", "command": "workbench.action.moveEditorRightInGroup" },
  { "key": "ctrl+shift+cmd+[", "command": "workbench.action.moveEditorLeftInGroup" },
  { "key": "ctrl+shift+cmd+]", "command": "workbench.action.moveEditorRightInGroup" },

  // Suggest fixes like WebStorm
  // Different from Tab and Ctrl+Space
  { "key": "ctrl+.", "command": "editor.action.quickFix", "when": "editorHasCodeActionsProvider && textInputFocus && !editorReadonly" },

  // Open settings with Cmd-, or Ctrl-,
  // Cmd, Ctrl and Alt all do the same
  // Hold Shift to open JSON
  // Hold Control (on macOS) or Alt (on other platforms) to open Workspace Settings
  { "key": "cmd+,", "command": "workbench.action.openSettings" },
  { "key": "ctrl+,", "command": "workbench.action.openSettings" },
  { "key": "alt+,", "command": "workbench.action.openSettings" },
  { "key": "ctrl+cmd+,", "command": "workbench.action.openSettingsJson" },
  { "key": "ctrl+shift+,", "command": "workbench.action.openSettingsJson" },
  { "key": "ctrl+alt+,", "command": "workbench.action.openSettingsJson" },
  { "key": "shift+cmd+,", "command": "workbench.action.openWorkspaceSettings" },
  { "key": "shift+alt+,", "command": "workbench.action.openWorkspaceSettings" },
  { "key": "ctrl+shift+cmd+,", "command": "workbench.action.openWorkspaceSettingsFile" },
  { "key": "ctrl+shift+alt+,", "command": "workbench.action.openWorkspaceSettingsFile" },

  // On macOS, Ctrl-Tab and Ctrl-Shift-Tab let us cycle through recently used tabs
  // Unfortunately, if I use CapsLock as Ctrl, CapsLock-Shift-Tab does not work properly (VSCode sees is as Ctrl-Tab)
  // A workaround is then to offer Ctrl-Grave instead. This actually mirrors Windows and Linux behaviour of Alt-Tab / Alt-Grave.
  { "key": "ctrl+`", "command": "workbench.action.quickOpenNavigatePreviousInEditorPicker", "when": "inEditorsPicker && inQuickOpen" },
  // However we don't bind this one, because we don't want ctrl-` to _open_ the picker
  //{ "key": "ctrl+`", "command": "workbench.action.quickOpenLeastRecentlyUsedEditorInGroup", "when": "!activeEditorGroupEmpty" },

  // In the Ctrl-P file picker, Tab will navigate through various UI widgets, but I only want it to navigate the files (other widgets I can select with the mouse)
  // Unfortunately Shift+Tab doesn't seem to activate on macOS, so I have offered Shift=Grave and lone Grave for this
  { "key": "tab", "command": "workbench.action.quickOpenNavigateNextInFilePicker", "when": "inFilesPicker && inQuickOpen" },
  { "key": "shift+tab", "command": "workbench.action.quickOpenNavigatePreviousInFilePicker", "when": "inFilesPicker && inQuickOpen" },
  { "key": "shift+`", "command": "workbench.action.quickOpenNavigatePreviousInFilePicker", "when": "inFilesPicker && inQuickOpen" },
  { "key": "`", "command": "workbench.action.quickOpenNavigatePreviousInFilePicker", "when": "inFilesPicker && inQuickOpen" },

  // Also make Tab work for other lists in Command Palette
  { "key": "tab", "command": "quickInput.next", "when": "inQuickInput && quickInputType == 'quickPick'" },
  { "key": "shift+tab", "command": "quickInput.previous", "when": "inQuickInput && quickInputType == 'quickPick'" },
  { "key": "shift+`", "command": "quickInput.previous", "when": "inQuickInput && quickInputType == 'quickPick'" },
  { "key": "`", "command": "quickInput.previous", "when": "inQuickInput && quickInputType == 'quickPick'" },

  // Get parameter hints. This is Ctrl-Shift-Space / Cmd-Shift-Space by default, but here is another option
  { "key": "ctrl+shift+/", "command": "editor.action.triggerParameterHints", "when": "editorHasSignatureHelpProvider && editorTextFocus && !inDebugRepl" },
  // I wanted this, but I couldn't get them both to work together
  //{ "key": "ctrl+shift+/", "command": "editor.action.showDefinitionPreviewHover" },

  // These block us from sending `[` e.g. when pressing `f[` to search for `[` on the current line
  //{ "key": "[ f", "command": "runCommands", "args": { "commands": [ "workbench.view.explorer", "list.focusUp", "explorer.openAndPassFocus" ] }, "when": "!editorTextFocus && workbench.explorer.fileView.visible && vim.active && !inDebugRepl && vim.mode == 'Normal'" },
  //{ "key": "] f", "command": "runCommands", "args": { "commands": [ "workbench.view.explorer", "list.focusDown", "explorer.openAndPassFocus" ] }, "when": "!editorTextFocus && workbench.explorer.fileView.visible && vim.active && !inDebugRepl && vim.mode == 'Normal'" },
  // However we can use these to make [f and ]f work in the explorer, and continue using our keybinds in settings.json when focused on the editor
  { "key": "[ f", "command": "runCommands", "args": { "commands": [ "workbench.view.explorer", "list.focusUp", "explorer.openAndPassFocus" ] }, "when": "workbench.explorer.fileView.visible && filesExplorerFocus && !inputFocus" },
  { "key": "] f", "command": "runCommands", "args": { "commands": [ "workbench.view.explorer", "list.focusDown", "explorer.openAndPassFocus" ] }, "when": "workbench.explorer.fileView.visible && filesExplorerFocus && !inputFocus" },
  // We can't use these, because they break common Vim commands such as "d2<Enter>"
  //{ "key": "2 [ f", "command": "runCommands", "args": { "commands": [ "workbench.view.explorer", "list.focusUp", "list.focusUp", "explorer.openAndPassFocus" ] } },
  //{ "key": "2 ] f", "command": "runCommands", "args": { "commands": [ "workbench.view.explorer", "list.focusDown", "list.focusDown", "explorer.openAndPassFocus" ] } },

  // When the editor is focused, we can use these Vim bindings from settings.json
  // But when we are focused, e.g. on a UI window, they don't work.  So we add them here.
  // We need to exclude most text boxes, so we can type `[` and `]` in them.
  // !composerFocused is needed for Cursor's AI chat
  // We could remove the `[b` and `]b` keybinds from settings.json, and use only these keybinds here, if we remove the first three conditions.
  { "key": "[ b", "command": "workbench.action.previousEditor", "when": "!editorFocus && !inputFocus && !textInputFocus && !inputBoxFocus && !composerFocused && !chatInputHasFocus && !inChatInput" },
  { "key": "] b", "command": "workbench.action.nextEditor", "when": "!editorFocus && !inputFocus && !textInputFocus && !inputBoxFocus && !composerFocused && !chatInputHasFocus && !inChatInput" },

  // Open list finder
  // Especially useful in the file explorer in filter mode, (i.e. when `filesExplorerFocus` is true) but may work in other lists
  { "key": "cmd+f", "command": "list.find", "when": "listFocus && listSupportsFind" },
  { "key": "ctrl+f", "command": "list.find", "when": "listFocus && listSupportsFind" },
  { "key": "alt+f", "command": "list.find", "when": "listFocus && listSupportsFind" },

  // Disable keybinds that may be interfering with "Copy With Imports" extension
  // It turns out it was only the Vim keybinds which were a problem
  //{ "key": "cmd+c", "command": "-execCopy" },
  //{ "key": "ctrl+c", "command": "-execCopy" },
  //{ "key": "cmd+v", "command": "-execPaste" },
  //{ "key": "ctrl+v", "command": "-execPaste" },
  //{ "key": "cmd+c", "command": "-editor.action.clipboardCopyAction" },
  //{ "key": "ctrl+c", "command": "-editor.action.clipboardCopyAction" },
  //{ "key": "cmd+v", "command": "-editor.action.clipboardPasteAction" },
  //{ "key": "ctrl+v", "command": "-editor.action.clipboardPasteAction" },
  { "key": "cmd+c", "command": "-extension.vim_cmd+c" },
  { "key": "ctrl+c", "command": "-extension.vim_ctrl+c" },
  { "key": "cmd+v", "command": "-extension.vim_cmd+v" },
  { "key": "ctrl+v", "command": "-extension.vim_ctrl+v" },

  // Allow CTRL-F in terminal to pass down to shell, move it to CTRL-SHIFT-F instead
  { "key": "ctrl+f",       "command": "-workbench.action.terminal.focusFind", "when": "terminalFindFocused && terminalHasBeenCreated || terminalFindFocused && terminalProcessSupported || terminalFocusInAny && terminalHasBeenCreated || terminalFocusInAny && terminalProcessSupported" },
  { "key": "ctrl+shift+f", "command":  "workbench.action.terminal.focusFind", "when": "terminalFindFocused && terminalHasBeenCreated || terminalFindFocused && terminalProcessSupported || terminalFocusInAny && terminalHasBeenCreated || terminalFocusInAny && terminalProcessSupported" },
  { "key": "ctrl+shift+t", "command": "workbench.action.terminal.new", "when": "terminalFocusInAny && (terminalProcessSupported || terminalWebExtensionContributedProfile)" },
  { "key": "cmd+t", "command": "workbench.action.terminal.new", "when": "terminalFocusInAny && (terminalProcessSupported || terminalWebExtensionContributedProfile)" },

  /* ==== Keybindings for AI tools ==== {{{ */

  // Disable existing keybindings which use Cmd-L or Alt-L
  { "key": "cmd+l", "command": "-expandLineSelection", "when": "textInputFocus" },
  { "key": "alt+l", "command": "toggleSearchEditorContextLines", "when": "inSearchEditor" },
  //
  { "key": "cmd+l cmd+c", "command": "-fiveServer.close", "when": "editorTextFocus" },
  { "key": "alt+l alt+c", "command": "-fiveServer.close", "when": "editorTextFocus" },
  { "key": "cmd+l cmd+o", "command": "-fiveServer.openViaShortcut", "when": "editorTextFocus" },
  { "key": "alt+l alt+o", "command": "-fiveServer.openViaShortcut", "when": "editorTextFocus" },

  // Most AI chats open with cmd+l/ctrl+l. But I want to keep ctrl+l for cleaning up the screen (the same as I have in Vim).
  // Unfortunately this doesn't work well if I keep them all in one keybindings.json
  // Enabling some alt+l commands prevents others from working!
  // For now, I'm enabling and disabling these keybindings, depending on which IDE I'm using.

  // Offer me some inline suggestions
  // I don't really need/use this yet, so we could make it do something else.
  // It's just here for experimentation.
  { "key": "ctrl+shift+space", "command": "editor.action.inlineSuggest.trigger" },

  // Autocomplete on Ctrl+Shift+Enter instead of on Tab
  // This is used by Intellisense and Continue and others (probably Windsurf) but not by Cursor
  { "key": "ctrl+shift+enter", "command": "editor.action.inlineSuggest.commit", "when": "inlineSuggestionVisible && textInputFocus" },

  // Continue
  // Make keys on Linux like those on macOS
  { "key": "ctrl+l", "command": "-continue.focusContinueInput" },
  { "key": "alt+l", "command": "continue.focusContinueInput", "when": "continue.focusContinueInput" },

  // Cursor
  // Autocomplete on Ctrl+Shift+Enter instead of on Tab
  //{ "key": "tab", "command": "-editor.action.acceptCursorTabSuggestion", "when": "cpp.shouldAcceptTab" },
  //{ "key": "ctrl+shift+enter", "command": "editor.action.acceptCursorTabSuggestion", "when": "cpp.shouldAcceptTab" },
  //// We might want to discourage the use of this, because I currently use that as a macro for Up-Enter
  ////{ "key": "cmd+shift+enter", "command": "editor.action.acceptCursorTabSuggestion", "when": "cpp.shouldAcceptTab" },
  //{ "key": "cmd+enter", "command": "-chatEditor.action.accept", "when": "chat.hasEditorModifications && editorFocus && hasUndecidedChatEditingResource && !chat.ctxHasRequestInProgress || chat.hasNotebookEditorModifications && editorFocus && hasUndecidedChatEditingResource && !chat.ctxHasRequestInProgress" },
  //{ "key": "ctrl+enter", "command": "chatEditor.action.accept", "when": "chat.hasEditorModifications && editorFocus && hasUndecidedChatEditingResource && !chat.ctxHasRequestInProgress || chat.hasNotebookEditorModifications && editorFocus && hasUndecidedChatEditingResource && !chat.ctxHasRequestInProgress" },
  //// Make keys on Linux like those on macOS
  //{ "key": "ctrl+l", "command": "-aichat.newchataction" },
  //{ "key": "alt+l", "command": "aichat.newchataction" },
  //{ "key": "ctrl+k", "command": "-aipopup.action.modal.generate", "when": "editorFocus && !composerBarIsVisible" },
  //{ "key": "alt+k alt+l", "command": "aipopup.action.modal.generate", "when": "editorFocus && !composerBarIsVisible" },
  //{ "key": "cmd+k cmd+l", "command": "aipopup.action.modal.generate", "when": "editorFocus && !composerBarIsVisible" },
  //// The Partial Accept feature (when enabled)
  //// This is usually on Cmd+Right, but that doesn't seem to work on macOS. Let's map it to ctrl+right instead.
  //{ "key": "ctrl+right", "command": "editor.action.inlineSuggest.acceptNextWord", "when": "cppSuggestion && !editorReadonly || inlineSuggestionVisible && !editorReadonly" },
  //// But on macOS, my Karabiner maps ctrl+right to alt+right, so we had better map that instead!
  //{ "key": "alt+right", "command": "editor.action.inlineSuggest.acceptNextWord", "when": "cppSuggestion && !editorReadonly || inlineSuggestionVisible && !editorReadonly" },

  // Windsurf (they call their AI Chat "Cascade")
  // Make keys on Linux like those on macOS
  //{ "key": "ctrl+l", "command": "-windsurf.prioritized.chat.open", "when": "!terminalFocus" },
  //{ "key": "alt+l", "command": "windsurf.prioritized.chat.open", "when": "windsurf.prioritized.chat.open" },
  // I don't know if we need to adjust this one
  ////{ "key": "ctrl+l", "command": "-windsurf.prioritized.chat.openFromTerminal", "when": "terminalFocus" },

  // ??? I don't know what sets these!
  // I did have a lot of AI tools installed at that time
  //{ "key": "ctrl+l", "command": "-workbench.action.chat.newChat", "when": "chatIsEnabled && inChat && !config.chat.unifiedChatView && chatLocation != 'editing-session'" },
  //{ "key": "ctrl+l", "command": "-workbench.action.chat.newChat", "when": "chatIsEnabled && inChat && chatLocation != 'editing-session'" },
  //{ "key": "ctrl+l", "command": "-workbench.action.chat.newEditSession", "when": "chatEditingParticipantRegistered && chatIsEnabled && inChat" },
  //{ "key": "ctrl+l", "command": "-workbench.action.chat.newEditSession", "when": "chatEditingParticipantRegistered && chatIsEnabled && inChat && chatLocation == 'editing-session'" },
  //{ "key": "alt+l", "command": "workbench.action.chat.newChat", "when": "chatIsEnabled && inChat && !config.chat.unifiedChatView && chatLocation != 'editing-session'" },
  //{ "key": "alt+l", "command": "workbench.action.chat.newEditSession", "when": "chatEditingParticipantRegistered && chatIsEnabled && inChat" },

  /* }}} */

  // I was trying to debug why jumping was not bringing the Vim cursor, but this is a known issue which I cannot resolve this way
  ////{ "key": "ctrl+]", "command": "-extension.vim_ctrl+]", "when": "editorTextFocus && vim.active && vim.use<C-]> && !inDebugRepl" },
  // It seems my override here will work, even if I don't disable VSCodeVim's default
  //{ "key": "ctrl+]", "command": "editor.action.revealDefinition", "when": "editorHasDefinitionProvider && editorTextFocus" },
  //{ "key": "ctrl+]", "command": "typescript.goToSourceDefinition", "when": "editorTextFocus && vim.active && vim.use<C-]> && !inDebugRepl" },
  //{ "key": "ctrl+shift+]", "command": "extension.vim_ctrl+]", "when": "editorTextFocus && vim.active && vim.use<C-]> && !inDebugRepl" },

  // Dummy object, because without this, newly added bindings expand the last entry in the file
  {
    "foo": "bar"
  },
  // --- NEW KEYBINDS SHOULD BE MOVED ABOVE THIS ---
]
