// Place your key bindings in this file to override the defaults
// prettier-ignore
[
  // When composing "when" conditions, you may like to view what is available, using:
  //     >Developer: Toggle Developer Tools
  //     and
  //     >Developer: Inspect Context Keys
  // https://code.visualstudio.com/api/references/when-clause-contexts

  // Navigation like WebStorm on Mac
  { "key": "alt+shift+[", "command": "workbench.action.previousEditor" },
  { "key": "alt+shift+]", "command": "workbench.action.nextEditor" },
  { "key": "alt+[", "command": "workbench.action.navigateBack" },
  { "key": "alt+]", "command": "workbench.action.navigateForward" },
  { "key": "ctrl+alt+[", "command": "workbench.action.navigateBack" },
  { "key": "ctrl+alt+]", "command": "workbench.action.navigateForward" },

  // Text movement and selection like Mac (beginning/end of file not done)
  { "key": "alt+right", "command": "cursorEnd", "when": "textInputFocus" },
  { "key": "alt+shift+right", "command": "cursorEndSelect", "when": "textInputFocus" },
  { "key": "alt+left", "command": "cursorHome", "when": "textInputFocus" },
  { "key": "alt+shift+left", "command": "cursorHomeSelect", "when": "textInputFocus" },
  { "key": "meta+right", "command": "cursorWordEndRight", "when": "textInputFocus" },
  { "key": "meta+shift+right", "command": "cursorWordEndRightSelect", "when": "textInputFocus" },
  { "key": "meta+left", "command": "cursorWordStartLeft", "when": "textInputFocus" },
  { "key": "meta+shift+left", "command": "cursorWordStartLeftSelect", "when": "textInputFocus" },
  { "key": "alt+shift+down", "command": "editor.action.moveLinesDownAction", "when": "editorTextFocus && !editorReadonly" },
  { "key": "alt+shift+up", "command": "editor.action.moveLinesUpAction", "when": "editorTextFocus && !editorReadonly" },

  // More Mac-like binds using Cmd
  { "key": "alt+shift+f", "command": "workbench.view.search", "when": "!searchViewletVisible" },
  { "key": "alt+backspace", "command": "editor.action.deleteLines", "when": "textInputFocus && !editorReadonly" },
  // I am now using the default (Opt-Shift-F on Mac, Ctrl-Shift-I on Linux)
  /*
  { "key": "alt+shift+l", "command": "editor.action.formatDocument", "when": "editorTextFocus && !editorReadonly" },
  { "key": "alt+shift+p", "command": "editor.action.formatDocument", "when": "editorTextFocus && !editorReadonly" },
  { "key": "ctrl+alt+shift+p", "command": "editor.action.formatDocument", "when": "editorTextFocus && !editorReadonly" },
  */
  { "key": "alt+z", "command": "undo", "when": "textInputFocus && !editorReadonly" },
  { "key": "alt+shift+z", "command": "redo", "when": "textInputFocus && !editorReadonly" },

  /*
  // Text manipulation like Mac
  // Note: There are a lot of definitions for ctrl+c, but we have only mirrored the main one so far.
  { "key": "alt+c", "command": "editor.action.clipboardCopyAction", "when": "textInputFocus" },
  { "key": "alt+x", "command": "editor.action.clipboardCutAction", "when": "textInputFocus && !editorReadonly" },
  { "key": "alt+v", "command": "editor.action.clipboardPasteAction", "when": "textInputFocus && !editorReadonly" },
  { "key": "alt+/", "command": "editor.action.commentLine", "when": "editorTextFocus && !editorReadonly" },

  // Walk through search results with Alt-Up/Down (VSCode default is F4, Shift-F4)
  { "key": "alt+down", "command": "goToNextReferenceFromEmbeddedEditor", "when": "inReferenceSearchEditor" },
  { "key": "alt+up", "command": "goToPreviousReferenceFromEmbeddedEditor", "when": "inReferenceSearchEditor" },
  { "key": "alt+down", "command": "search.action.focusNextSearchResult", "when": "hasSearchResult" },
  { "key": "alt+up", "command": "search.action.focusPreviousSearchResult", "when": "hasSearchResult" },
  { "key": "alt+down", "command": "goToNextReference", "when": "referenceSearchVisible" },
  { "key": "alt+up", "command": "goToPreviousReference", "when": "referenceSearchVisible" },

  { "key": "ctrl+g", "command": "editor.action.nextMatchFindAction", "when": "editorFocus" },
  { "key": "ctrl+shift+g", "command": "editor.action.previousMatchFindAction", "when": "editorFocus" },
  { "key": "ctrl+l", "command": "workbench.action.gotoLine" },
  { "key": "ctrl+backspace", "command": "deleteRight", "when": "textInputFocus && !editorReadonly" },
  { "key": "ctrl+shift+j", "command": "editor.action.joinLines", "when": "editorFocus" },
  */

  { "key": "ctrl+=", "command": "editor.action.fontZoomIn" },
  { "key": "ctrl+-", "command": "editor.action.fontZoomOut" },
  { "key": "ctrl+0", "command": "editor.action.fontZoomReset" },
  { "key": "ctrl+shift+=", "command": "workbench.action.zoomIn" },
  { "key": "ctrl+shift+-", "command": "workbench.action.zoomOut" },
  { "key": "ctrl+shift+0", "command": "workbench.action.zoomReset" },

  { "key": "meta+up", "command": "editor.action.addSelectionToNextFindMatch", "when": "editorFocus" },

  /*
  { "key": "alt+z", "command": "workbench.action.maximizeEditor" },
  */

  { "key": "ctrl+shift+\\", "command": "workbench.action.splitEditorOrthogonal" },

  { "key": "alt+w", "command": "workbench.action.closeWindow", "when": "!editorIsOpen && !multipleEditorGroups" },

  /* To match Linux keybinds on macOS */
  { "key": "ctrl+shift+p", "command": "workbench.action.showCommands" },

  /* To match macOS keybinds on Linux/Windows */
  { "key": "meta+shift-f", "command": "editor.action.formatDocument", "when": "editorTextFocus && !editorReadonly" },
  { "key": "meta+shift+o", "command": "editor.action.organizeImports", "when": "editorTextFocus && !editorReadonly && supportedCodeAction =~ /(\\s|^)source\\.organizeImports\\b/" },
  { "key": "alt-j", "command": "workbench.action.togglePanel" },
  { "key": "alt-p", "command": "workbench.action.quickOpen" },
  { "key": "alt+p", "command": "workbench.action.quickOpenNavigateNextInFilePicker", "when": "inFilesPicker && inQuickOpen" },
  { "key": "alt+shift+p", "command": "workbench.action.quickOpenNavigatePreviousInFilePicker", "when": "inFilesPicker && inQuickOpen" },
  { "key": "alt+shift+p", "command": "workbench.action.showCommands", "when": "!inFilesPicker || !inQuickOpen" },
  { "key": "alt+shift+e", "command": "workbench.view.explorer" },
  // To train me to use Cmd-P / Alt-P instead of Ctrl-P
  { "key": "ctrl+p", "command": "-workbench.action.quickOpen" },

  { "key": "cmd+[", "command": "-editor.action.outdentLines", "when": "editorTextFocus && !editorReadonly" },
  { "key": "cmd+]", "command": "-editor.action.indentLines", "when": "editorTextFocus && !editorReadonly" },
  { "key": "cmd+[", "command": "workbench.action.navigateBack", "when": "canNavigateBack"  },
  { "key": "cmd+]", "command": "workbench.action.navigateForward", "when": "canNavigateForward"  },

  // On Linux ctrl+shift+e should trigger "workbench.view.explorer" but GTK might hijack it for a new emoji feature.
  // If you want it back, you may try to disable GTK's hijacking: https://github.com/microsoft/vscode/issues/48480

  //{ "key": "alt+s", "command": "workbench.action.files.save" },
  { "key": "alt+s", "command": "workbench.action.files.saveAll" },
  { "key": "ctrl+s", "command": "workbench.action.files.saveAll" },

  // Disable these VSCode defaults, because I need to use these keys in Vim mode
  { "key": "ctrl+w", "command": "-workbench.action.closeWindow", "when": "!editorIsOpen && !multipleEditorGroups" },
  { "key": "ctrl+w", "command": "-workbench.action.closeGroup", "when": "activeEditorGroupEmpty && multipleEditorGroups" },
  { "key": "ctrl+w", "command": "-workbench.action.closeActiveEditor", "when": "editorFocus" },
  /* Enable it only when there is one window pane (no splits) */
  //{ "key": "ctrl+w", "command": "workbench.action.closeActiveEditor", "when": "editorFocus && !multipleEditorGroups" },

  // Disable these Vim defaults, because I don't use them, and I would rather use the VSCode shortcuts
  { "key": "ctrl+f", "command": "-extension.vim_ctrl+f", "when": "editorTextFocus && vim.active && vim.use<C-f> && !inDebugRepl && vim.mode != 'Insert'" },

  { "key": "alt+shift+f", "command": "workbench.action.findInFiles" },
  // Oddly, while there was a System setting like this on macOS, it didn't work until I created an identical user setting
  { "key": "cmd+shift+f", "command": "workbench.action.findInFiles" },
  // Let's also put it on this
  { "key": "ctrl+shift+f", "command": "workbench.action.findInFiles" },

  //{ "key": "ctrl+n", "command": "!extension.vim_ctrl+n", "when": "editorTextFocus && vim.active && vim.use<C-n> && !inDebugRepl || vim.active && vim.use<C-n> && !inDebugRepl && vim.mode == 'CommandlineInProgress' || vim.active && vim.use<C-n> && !inDebugRepl && vim.mode == 'SearchInProgressMode'" },
  //{ "key": "ctrl+p", "command": "!extension.vim_ctrl+p", "when": "suggestWidgetVisible && vim.active && vim.use<C-p> && !inDebugRepl || vim.active && vim.use<C-p> && !inDebugRepl && vim.mode == 'CommandlineInProgress' || vim.active && vim.use<C-p> && !inDebugRepl && vim.mode == 'SearchInProgressMode'" },

  //{ "key": "ctrl+n", "command": "search.action.focusNextSearchResult", "when": "hasSearchResult" },
  //{ "key": "ctrl+p", "command": "search.action.focusPreviousSearchResult", "when": "hasSearchResult" },

  // It looks like when multiple bindings match, it uses the later one
  { "key": "alt+meta+down", "command": "references-view.next", "when": "reference-list.hasResult && references-view.canNavigate" },
  { "key": "alt+meta+up", "command": "references-view.prev", "when": "reference-list.hasResult && references-view.canNavigate" },
  { "key": "alt+meta+down", "command": "search.action.focusNextSearchResult", "when": "hasSearchResult || inSearchEditor" },
  { "key": "alt+meta+up", "command": "search.action.focusPreviousSearchResult", "when": "hasSearchResult || inSearchEditor" },
  // If multiple "when"s match, VSCode seems to prefer the later one, i.e. search above.
  // So if I really want references instead of search results, I'll hold down shift.
  { "key": "shift+alt+meta+down", "command": "references-view.next", "when": "reference-list.hasResult" },
  { "key": "shift+alt+meta+up", "command": "references-view.prev", "when": "reference-list.hasResult" },
  // There is reference-list.isActive but that is always true, and referenceSearchVisible but that is always false
  // So it seems neither of those refer to the visibiility of the sidebar panel, which is what I'm interested in
  //
  // VSCode's finder currently loses your position in the search results if you edit the line for the current result, or one of the line above it in the file.
  // This is really annoying!  Using search.action.remove on every result can help with this, because it drops the current result, so if you do lose your place, you won't need to visit this discarded line again.
  // Default: Ctrl/Cmd-Backspace but that does something destructive if the editor is focused
  //{ "key": "alt+meta+right", "command": "search.action.remove", "when": "hasSearchResult || inSearchEditor" },
  { "key": "alt+meta+right", "command": "runCommands", "args": { "commands": [ "search.action.focusSearchList", "search.action.remove" ] }, "when": "hasSearchResult || inSearchEditor" },
  //
  // BUG: Since Feb/March 2025, using F4 or alt+meta+down results in the search text being selected. I don't want this!
  // I tried to cancel the text selection, but this still kept it selected
  //{ "key": "alt+meta+down", "command": "runCommands", "args": { "commands": [ "search.action.focusNextSearchResult", "workbench.action.focusActiveEditorGroup", "setSelection", "cancelSelection", "editor.action.cancelSelectionAnchor", "cursorEndSelect", "removeSecondaryCursors" ] }, "when": "hasSearchResult || inSearchEditor" },
  // Undoing these didn't make any difference (and certainly wouldn't to F4)
  //{ "key": "alt+meta+down", "command": "-editor.action.insertCursorBelow", "when": "editorTextFocus" },
  //{ "key": "alt+meta+up", "command": "-editor.action.insertCursorAbove", "when": "editorTextFocus" },
  //{ "key": "alt+cmd+down", "command": "-editor.action.insertCursorBelow", "when": "editorTextFocus" },
  //{ "key": "alt+cmd+up", "command": "-editor.action.insertCursorAbove", "when": "editorTextFocus" },

  // When focused on search, get back to editor by pressing Escape
  // I couldn't find a "when" for when the references results are focused, so I would like to enable this always.
  // But if I use an empty "when" then I cannot escape from Vim's insert mode.
  { "key": "escape", "command": "workbench.action.focusActiveEditorGroup", "when": "searchInputBoxFocus" },
  // One of the popups is difficult to get rid of.  Well it's possible with Shift-Escape (or Shift-Escape via Ctrl-L) but I just want Escape to remove it.
  // I'm not sure which popup it is exactly, because there are a lot bound to Shift-Escape.  (So it might not be the suggestionWidget at all.)
  // This attempt was problematic because, when autocomplete menu is focused, usually <Escape> will also break out of Vim's INSERT mode.  With this keybinding enabled, <Escape> closes the autocomplete menu, but it didn't leave INSERT mode.
  //{ "key": "escape", "command": "hideSuggestWidget", "when": "suggestWidgetVisible && textInputFocus" },

  // When focused on file explorer, get back to editor by pressing Escape
  { "key": "escape", "command": "workbench.action.focusActiveEditorGroup", "when": "explorerViewletVisible && filesExplorerFocus && !inputFocus" },

  // A catch all, which should leave the sidebar whenever focus is there
  // The case I needed this was after `gU` aka `references-view.find`
  { "key": "escape", "command": "workbench.action.focusActiveEditorGroup", "when": "!editorFocus && !terminalFocus && !terminalFindFocus && !inputFocus" },
  // It might be preferable to whitelist when we do want this to happen, rather than blacklist, but inventing this state boolean didn't work for me
  //{ "key": "escape", "command": "workbench.action.focusActiveEditorGroup", "when": "sidebarFocus" },

  // Use Tab to open autocomplete suggestions, and cycle through them
  // This sometimes doesn't work, but we fall back to "editor.tabCompletion" to open the suggestion list
  { "key": "tab", "command": "editor.action.triggerSuggest", "when": "editorHasCompletionItemProvider && textInputFocus && !editorReadonly && atEndOfWord" },
  // This is helpful if "editor.tabCompletion" is "off" but it prevents us from inserting real Tabs onto an empty line
  //{ "key": "tab", "command": "editor.action.triggerSuggest", "when": "editorHasCompletionItemProvider && textInputFocus && !editorReadonly" },
  //{ "key": "tab", "command": "selectNextSuggestion", "when": "suggestWidgetMultipleSuggestions && suggestWidgetVisible && textInputFocus" },
  //{ "key": "shift-tab", "command": "selectPrevSuggestion", "when": "suggestWidgetMultipleSuggestions && suggestWidgetVisible && textInputFocus" },
  { "key": "tab", "command": "selectNextSuggestion", "when": "suggestWidgetVisible && textInputFocus" },
  { "key": "shift-tab", "command": "selectPrevSuggestion", "when": "suggestWidgetVisible && textInputFocus" },

  // Select the suggestion even if it's not focused
  // This is an old VSCode habit which I should try to avoid
  { "key": "enter", "command": "acceptSelectedSuggestion", "when": "suggestWidgetVisible && textInputFocus" },
  // This allows me to hit Tab-Enter to select and accept the suggestion.
  // Without this, Tab-Enter would select the suggestion but then discard it and start a new line!

  // Act more like Vim, by accepting the current suggestion, if we keep typing
  { "key": "space", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": " "} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": ".", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "."} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": ",", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": ","} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": ";", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": ";"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "shift-;", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": ":"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  // ( and )
  { "key": "shift-9", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "("} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "shift-0", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": ")"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "[", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "["} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "]", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "]"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "shift-[", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "{"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "shift-]", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "}"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "'", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "'"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  // I put text: "" for this one, because VSCode likes to enter two quotes instead of one
  { "key": "shift-'", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": ""} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "`", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "`"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  // ! and ?
  { "key": "shift-1", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "!"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "shift-/", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "?"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "/", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "/"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "'", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "'"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  // < and >
  { "key": "shift-,", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": "<"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },
  { "key": "shift-.", "command": "runCommands",   "args": { "commands": [ "acceptSelectedSuggestion", { "command": "type", "args": {"text": ">"} } ] }, "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus && !inDebugRepl" },

  //{ "key": "tab", "command": "acceptSelectedSuggestion", "when": "acceptSuggestionOnEnter && suggestWidgetVisible && suggestionMakesTextEdit && textInputFocus" },

  // I usually have inline suggestions disabled, but not always
  // This is needed for Complete
  { "key": "ctrl+shift+enter", "command": "editor.action.inlineSuggest.commit", "when": "inlineSuggestionVisible && textInputFocus" },

  // Use Tab to cycle whenever a list is focused
  // I find this useful when jumping to a definition, when multiple suggestions are offered
  { "key": "tab", "command": "list.focusDown", "when": "listFocus" },
  { "key": "shift-tab", "command": "list.focusUp", "when": "listFocus" },

  // More lists that should use Tab to cycle
  { "key": "tab", "command": "selectNextCodeAction", "when": "codeActionMenuVisible" },
  { "key": "shift-tab", "command": "selectPrevCodeAction", "when": "codeActionMenuVisible" },
  { "key": "tab", "command": "showNextParameterHint", "when": "editorFocus && parameterHintsMultipleSignatures && parameterHintsVisible && !suggestWidgetVisible" },
  { "key": "shift-tab", "command": "showPrevParameterHint", "when": "editorFocus && parameterHintsMultipleSignatures && parameterHintsVisible && !suggestWidgetVisible" },

  // Using VSCodeVim, when focused on the explorer/sidebar I would often try to use `Ctrl-W Right` to get back to the editor.
  // But in VSCode, Ctrl+W closes the current editor!  So I made this mapping to intercept that.
  { "key": "ctrl+w Right", "command": "workbench.action.focusActiveEditorGroup", "when": "explorerViewletVisible && filesExplorerFocus && !inputFocus" },
  { "key": "ctrl+w l", "command": "workbench.action.focusActiveEditorGroup", "when": "explorerViewletVisible && filesExplorerFocus && !inputFocus" },
  { "key": "ctrl+[", "command": "workbench.action.focusActiveEditorGroup", "when": "explorerViewletVisible && filesExplorerFocus && !inputFocus" },
  { "key": "] w", "command": "workbench.action.focusActiveEditorGroup", "when": "explorerViewletVisible && filesExplorerFocus && !inputFocus" },

  /* Cycle zoom (requires Settings Cycler plugin) */
  /* I use this because I like -0.5 on my Linux, but Ctrl-Plus/Minus round to integers */
  {
    "key": "ctrl+shift+0",
    "command": "settings.cycle",
    //"when": "editorTextFocus",
    "args": {
      "id": "cycleResetZoom", // must be unique
      "overrideWorkspaceSettings": true,
      "values": [
        {
          //"window.zoomLevel": -0.5
          "window.zoomLevel": -0.8
        },
        {
          //"window.zoomLevel": -0.8
          "window.zoomLevel": -1
        },
        {
          //"window.zoomLevel": 0
          "window.zoomLevel": -0.5
        }
      ]
    }
  },

  // Cycle theme
  {
    "key": "cmd+k cmd+k",
    "command": "settings.cycle",
    "args": {
      "id": "cycleColorTheme", // must be unique
      "overrideWorkspaceSettings": true,
      "values": [
        // This is mine, it's nice and calm, but a bit boring
        { "workbench.colorTheme": "Gentle Mary" },
        // This one looks cool
        { "workbench.colorTheme": "Material Theme" },
        // Grey version
        { "workbench.colorTheme": "Material Theme Darker" },
        // These lighter themes are good when working in bright conditions
        //{ "workbench.colorTheme": "Material Theme Lighter High Contrast" },
        { "workbench.colorTheme": "Quiet Light" },
        { "workbench.colorTheme": "Visual Studio Light" },
        //{ "workbench.colorTheme": "Default Light +" },
        { "workbench.colorTheme": "Default Light Modern" },
      ]
    }
  },
  {
    "key": "alt+k alt+k",
    "command": "settings.cycle",
    "args": {
      "id": "cycleColorTheme", // must be unique
      "overrideWorkspaceSettings": true,
      "values": [
        // This is mine, it's nice and calm, but a bit boring
        { "workbench.colorTheme": "Gentle Mary" },
        // This one looks cool
        { "workbench.colorTheme": "Material Theme" },
        // Grey version
        { "workbench.colorTheme": "Material Theme Darker" },
        // These lighter themes are good when working in bright conditions
        //{ "workbench.colorTheme": "Material Theme Lighter High Contrast" },
        { "workbench.colorTheme": "Quiet Light" },
        { "workbench.colorTheme": "Visual Studio Light" },
        //{ "workbench.colorTheme": "Default Light +" },
        { "workbench.colorTheme": "Default Light Modern" },
      ]
    }
  },
  // The following was only needed when we had bound Cmd-K Cmd-T Cmd-T above
  // Since the above overrode the default Cmd-K Cmd-T, then let's create a new bind for it
  //{ "key": "cmd+k cmd+t cmd+k", "command": "workbench.action.selectTheme" },

  { "key": "ctrl+e", "command": "workbench.action.showAllEditorsByMostRecentlyUsed", "when": "editorTextFocus && vim.active && vim.use<C-]> && !inDebugRepl" },
  { "key": "ctrl+b", "command": "workbench.action.showEditorsInActiveGroup", "when": "editorTextFocus && vim.active && vim.use<C-]> && !inDebugRepl" },

  // When you want to insert a literal tab
  { "key": "ctrl+v tab", "command": "type", "args": { "text": "\t" }, "when": "editorTextFocus" },

  // VSCode now has good defaults for these (that work well when the terminal has been dragged into an editor tab)
  //{ "key": "ctrl+PageUp", "command": "workbench.action.terminal.focusPrevious", "when": "terminalFocus" },
  //{ "key": "ctrl+PageDown", "command": "workbench.action.terminal.focusNext", "when": "terminalFocus" },

  { "key": "ctrl+alt+shift+l", "command": "editor.action.formatDocument.multiple" },
  { "key": "ctrl+alt+shift+l", "command": "eslint.executeAutofix" },
  { "key": "ctrl+alt+shift+o", "command": "editor.action.organizeImports", "when": "editorTextFocus && !editorReadonly && supportedCodeAction =~ /(\\s|^)source\\.organizeImports\\b/" },

  // We can reach the Terminal with <Ctrl-W> <Down>, so we should be able to leave it with <Ctrl-W> <Up>
  // This might not go back where you were before, if you have multiple editor groups open (split windows)
  // (Sometimes I move the terminal to the left or right or the editors, so I define more keys)
  { "key": "ctrl+w Up", "command": "workbench.action.focusPreviousGroup", "when": "terminalFocus" },
  { "key": "ctrl+w k", "command": "workbench.action.focusPreviousGroup", "when": "terminalFocus" },
  { "key": "ctrl+w Left", "command": "workbench.action.focusPreviousGroup", "when": "terminalFocus" },
  { "key": "ctrl+w h", "command": "workbench.action.focusPreviousGroup", "when": "terminalFocus" },
  { "key": "ctrl+w Down", "command": "workbench.action.focusNextGroup", "when": "terminalFocus" },
  { "key": "ctrl+w j", "command": "workbench.action.focusNextGroup", "when": "terminalFocus" },
  { "key": "ctrl+w Right", "command": "workbench.action.focusNextGroup", "when": "terminalFocus" },
  { "key": "ctrl+w l", "command": "workbench.action.focusNextGroup", "when": "terminalFocus" },
  // More useful keys for the terminal
  { "key": "ctrl+w c", "command": "workbench.action.terminal.toggleTerminal", "when": "terminalFocus" },
  // This only works when the panel is aligned centrally
  { "key": "ctrl+z", "command": "workbench.action.toggleMaximizedPanel", "when": "terminalFocus" },
  // Trying to make it easy to re-align the panel, when I want to toggle maximization
  // Unfortunately these rarely trigger
  // , "when": "terminalFocus"
  //{ "key": "ctrl+a", "command": "workbench.action.alignPanelLeft" },
  //{ "key": "ctrl+x", "command": "workbench.action.positionPanelBottom" },

  // In my Terminal, I use Ctrl-F to move forward one word, so I want Find to be on Ctrl-Shift-F instead.
  { "key": "ctrl+f", "command": "-workbench.action.terminal.focusFind", "when": "terminalFindFocused && terminalHasBeenCreated || terminalFindFocused && terminalProcessSupported || terminalFocus && terminalHasBeenCreated || terminalFocus && terminalProcessSupported" },
  { "key": "ctrl+shift+f", "command": "workbench.action.terminal.focusFind", "when": "terminalFindFocused && terminalHasBeenCreated || terminalFindFocused && terminalProcessSupported || terminalFocus && terminalHasBeenCreated || terminalFocus && terminalProcessSupported" },

  // Experiment: I was trying to complement the C-L binding in settings.json
  // Result: This runs before, not after, the VSCodeVim binding
  // Another result we found is that, both here and there, if we define two bindings with the same key and same when, then the second binding one overwrites the first.
  //{ "key": "ctrl+l", "command": "workbench.action.toggleSidebarVisibility", "when": "sideBarVisible" },

  { "key": "shift+f10", "command": "editor.action.inspectTMScopes" },

  { "key": "cmd+1", "command": "-workbench.action.focusFirstEditorGroup" },
  { "key": "cmd+2", "command": "-workbench.action.focusSecondEditorGroup" },
  { "key": "cmd+3", "command": "-workbench.action.focusThirdEditorGroup" },
  { "key": "cmd+4", "command": "-workbench.action.focusFourthEditorGroup" },
  { "key": "cmd+5", "command": "-workbench.action.focusFifthEditorGroup" },
  { "key": "cmd+6", "command": "-workbench.action.focusSixthEditorGroup" },
  { "key": "cmd+7", "command": "-workbench.action.focusSeventhEditorGroup" },
  { "key": "cmd+8", "command": "-workbench.action.focusEighthEditorGroup" },
  { "key": "cmd+9", "command": "-workbench.action.focusLastEditorGroup" },
  { "key": "cmd+1", "command": "workbench.action.openEditorAtIndex1" },
  { "key": "cmd+2", "command": "workbench.action.openEditorAtIndex2" },
  { "key": "cmd+3", "command": "workbench.action.openEditorAtIndex3" },
  { "key": "cmd+4", "command": "workbench.action.openEditorAtIndex4" },
  { "key": "cmd+5", "command": "workbench.action.openEditorAtIndex5" },
  { "key": "cmd+6", "command": "workbench.action.openEditorAtIndex6" },
  { "key": "cmd+7", "command": "workbench.action.openEditorAtIndex7" },
  { "key": "cmd+8", "command": "workbench.action.openEditorAtIndex8" },
  { "key": "cmd+9", "command": "workbench.action.openEditorAtIndex9" },

  // Before adding these, on macOS, Ctrl-PageUp/Down were only working on editor windows, not on UI windows
  { "key": "ctrl+pageup", "command": "workbench.action.previousEditor" },
  { "key": "ctrl+pagedown", "command": "workbench.action.nextEditor" },
  //
  { "key": "ctrl+shift+pageup", "command": "workbench.action.moveEditorLeftInGroup" },
  { "key": "ctrl+shift+pagedown", "command": "workbench.action.moveEditorRightInGroup" },
  { "key": "ctrl+shift+cmd+[", "command": "workbench.action.moveEditorLeftInGroup" },
  { "key": "ctrl+shift+cmd+]", "command": "workbench.action.moveEditorRightInGroup" },

  // Suggest fixes like WebStorm
  // Different from Tab and Ctrl+Space
  { "key": "ctrl+.", "command": "editor.action.quickFix", "when": "editorHasCodeActionsProvider && textInputFocus && !editorReadonly" },

  // Open settings with Cmd-, or Ctrl-,
  // Cmd, Ctrl and Alt all do the same
  // Hold Shift to open JSON
  // Hold Control (on macOS) or Alt (on other platforms) to open Workspace Settings
  { "key": "cmd+,", "command": "workbench.action.openSettings" },
  { "key": "ctrl+,", "command": "workbench.action.openSettings" },
  { "key": "alt+,", "command": "workbench.action.openSettings" },
  { "key": "ctrl+cmd+,", "command": "workbench.action.openSettingsJson" },
  { "key": "ctrl+shift+,", "command": "workbench.action.openSettingsJson" },
  { "key": "ctrl+alt+,", "command": "workbench.action.openSettingsJson" },
  { "key": "shift+cmd+,", "command": "workbench.action.openWorkspaceSettings" },
  { "key": "shift+alt+,", "command": "workbench.action.openWorkspaceSettings" },
  { "key": "ctrl+shift+cmd+,", "command": "workbench.action.openWorkspaceSettingsFile" },
  { "key": "ctrl+shift+alt+,", "command": "workbench.action.openWorkspaceSettingsFile" },

  // On macOS, Ctrl-Tab and Ctrl-Shift-Tab let us cycle through recently used tabs
  // Unfortunately, if I use CapsLock as Ctrl, CapsLock-Shift-Tab does not work properly (VSCode sees is as Ctrl-Tab)
  // A workaround is then to offer Ctrl-Grave instead. This actually mirrors Windows and Linux behaviour of Alt-Tab / Alt-Grave.
  { "key": "ctrl+`", "command": "workbench.action.quickOpenNavigatePreviousInEditorPicker", "when": "inEditorsPicker && inQuickOpen" },
  // However we don't bind this one, because we don't want ctrl-` to _open_ the picker
  //{ "key": "ctrl+`", "command": "workbench.action.quickOpenLeastRecentlyUsedEditorInGroup", "when": "!activeEditorGroupEmpty" },

  // In the Ctrl-P file picker, Tab will navigate through various UI widgets, but I only want it to navigate the files (other widgets I can select with the mouse)
  // Unfortunately Shift+Tab doesn't seem to activate on macOS, so I have offered Shift=Grave and lone Grave for this
  { "key": "tab", "command": "workbench.action.quickOpenNavigateNextInFilePicker", "when": "inFilesPicker && inQuickOpen" },
  { "key": "shift+tab", "command": "workbench.action.quickOpenNavigatePreviousInFilePicker", "when": "inFilesPicker && inQuickOpen" },
  { "key": "shift+`", "command": "workbench.action.quickOpenNavigatePreviousInFilePicker", "when": "inFilesPicker && inQuickOpen" },
  { "key": "`", "command": "workbench.action.quickOpenNavigatePreviousInFilePicker", "when": "inFilesPicker && inQuickOpen" },

  // Also make Tab work for other lists in Command Palette
  { "key": "tab", "command": "quickInput.next", "when": "inQuickInput && quickInputType == 'quickPick'" },
  { "key": "shift+tab", "command": "quickInput.previous", "when": "inQuickInput && quickInputType == 'quickPick'" },
  { "key": "shift+`", "command": "quickInput.previous", "when": "inQuickInput && quickInputType == 'quickPick'" },
  { "key": "`", "command": "quickInput.previous", "when": "inQuickInput && quickInputType == 'quickPick'" },

  // This is Ctrl-Shift-Space / Cmd-Shift-Space by default, but here is another option
  { "key": "ctrl+shift+/", "command": "editor.action.triggerParameterHints", "when": "editorHasSignatureHelpProvider && editorTextFocus && !inDebugRepl" },
  // I wanted this, but I couldn't get them both to work together
  //{ "key": "ctrl+shift+/", "command": "editor.action.showDefinitionPreviewHover" },

  // These block us from sending `[` e.g. when pressing `f[` to search for `[` on the current line
  //{ "key": "[ f", "command": "runCommands", "args": { "commands": [ "workbench.view.explorer", "list.focusUp", "explorer.openAndPassFocus" ] }, "when": "!editorTextFocus && workbench.explorer.fileView.visible && vim.active && !inDebugRepl && vim.mode == 'Normal'" },
  //{ "key": "] f", "command": "runCommands", "args": { "commands": [ "workbench.view.explorer", "list.focusDown", "explorer.openAndPassFocus" ] }, "when": "!editorTextFocus && workbench.explorer.fileView.visible && vim.active && !inDebugRepl && vim.mode == 'Normal'" },
  // However we can use these to make [f and ]f work in the explorer, and continue using our keybinds in settings.json when focused on the editor
  { "key": "[ f", "command": "runCommands", "args": { "commands": [ "workbench.view.explorer", "list.focusUp", "explorer.openAndPassFocus" ] }, "when": "workbench.explorer.fileView.visible && filesExplorerFocus && !inputFocus" },
  { "key": "] f", "command": "runCommands", "args": { "commands": [ "workbench.view.explorer", "list.focusDown", "explorer.openAndPassFocus" ] }, "when": "workbench.explorer.fileView.visible && filesExplorerFocus && !inputFocus" },
  // We can't use these, because they break common Vim commands such as "d2<Enter>"
  //{ "key": "2 [ f", "command": "runCommands", "args": { "commands": [ "workbench.view.explorer", "list.focusUp", "list.focusUp", "explorer.openAndPassFocus" ] } },
  //{ "key": "2 ] f", "command": "runCommands", "args": { "commands": [ "workbench.view.explorer", "list.focusDown", "list.focusDown", "explorer.openAndPassFocus" ] } },

  // When the editor is focused, we can use these Vim bindings from settings.json
  // But when we are focused, e.g. on a UI window, they don't work.  So we add them here.  (Theoretically, we only need them here, with no conditions.)
  { "key": "[ b", "command": "workbench.action.previousEditor", "when": "!editorFocus && !inputFocus" },
  { "key": "] b", "command": "workbench.action.nextEditor", "when": "!editorFocus && !inputFocus" },

  // Open list finder
  // Especially useful in the file explorer in filter mode, (i.e. when `filesExplorerFocus` is true) but may work in other lists
  { "key": "cmd+f", "command": "list.find", "when": "listFocus && listSupportsFind" },
  { "key": "ctrl+f", "command": "list.find", "when": "listFocus && listSupportsFind" },
  { "key": "alt+f", "command": "list.find", "when": "listFocus && listSupportsFind" },

  // Disable keybinds that may be interfering with "Copy With Imports" extension
  // It turns out it was only the Vim keybinds which were a problem
  //{ "key": "cmd+c", "command": "-execCopy" },
  //{ "key": "ctrl+c", "command": "-execCopy" },
  //{ "key": "cmd+v", "command": "-execPaste" },
  //{ "key": "ctrl+v", "command": "-execPaste" },
  //{ "key": "cmd+c", "command": "-editor.action.clipboardCopyAction" },
  //{ "key": "ctrl+c", "command": "-editor.action.clipboardCopyAction" },
  //{ "key": "cmd+v", "command": "-editor.action.clipboardPasteAction" },
  //{ "key": "ctrl+v", "command": "-editor.action.clipboardPasteAction" },
  { "key": "cmd+c", "command": "-extension.vim_cmd+c" },
  { "key": "ctrl+c", "command": "-extension.vim_ctrl+c" },
  { "key": "cmd+v", "command": "-extension.vim_cmd+v" },
  { "key": "ctrl+v", "command": "-extension.vim_ctrl+v" },

  // Allow CTRL-F in terminal to pass down to shell, move it to CTRL-SHIFT-F instead
  { "key": "ctrl+f",       "command": "-workbench.action.terminal.focusFind", "when": "terminalFindFocused && terminalHasBeenCreated || terminalFindFocused && terminalProcessSupported || terminalFocusInAny && terminalHasBeenCreated || terminalFocusInAny && terminalProcessSupported" },
  { "key": "ctrl+shift+f", "command":  "workbench.action.terminal.focusFind", "when": "terminalFindFocused && terminalHasBeenCreated || terminalFindFocused && terminalProcessSupported || terminalFocusInAny && terminalHasBeenCreated || terminalFocusInAny && terminalProcessSupported" },
  { "key": "ctrl+shift+t", "command": "workbench.action.terminal.new", "when": "terminalFocusInAny && (terminalProcessSupported || terminalWebExtensionContributedProfile)" },
  { "key": "cmd+t", "command": "workbench.action.terminal.new", "when": "terminalFocusInAny && (terminalProcessSupported || terminalWebExtensionContributedProfile)" },

  // I was trying to debug why jumping was not bringing the Vim cursor, but this is a known issue which I cannot resolve this way
  ////{ "key": "ctrl+]", "command": "-extension.vim_ctrl+]", "when": "editorTextFocus && vim.active && vim.use<C-]> && !inDebugRepl" },
  // It seems my override here will work, even if I don't disable VSCodeVim's default
  //{ "key": "ctrl+]", "command": "editor.action.revealDefinition", "when": "editorHasDefinitionProvider && editorTextFocus" },
  //{ "key": "ctrl+]", "command": "typescript.goToSourceDefinition", "when": "editorTextFocus && vim.active && vim.use<C-]> && !inDebugRepl" },
  //{ "key": "ctrl+shift+]", "command": "extension.vim_ctrl+]", "when": "editorTextFocus && vim.active && vim.use<C-]> && !inDebugRepl" },

  // Dummy object, because without this, newly added bindings expand the last entry in the file
  {
    "foo": "bar"
  },
  // --- NEW KEYBINDS SHOULD BE MOVED ABOVE THIS ---
]
